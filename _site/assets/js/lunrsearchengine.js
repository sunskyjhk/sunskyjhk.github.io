
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "http://localhost:4000/about",
    "title": "Mediumish Template for Jekyll",
    "body": "This website is built with Jekyll and Mediumish template for Jekyll. It's for demonstration purposes, no real content can be found. Mediumish template for Jekyll is compatible with Github pages, in fact even this demo is created with Github Pages and hosted with Github.  Documentation: Please, read the docs here. Questions or bug reports?: Head over to our Github repository! Buy me a coffeeThank you for your support! Your donation helps me to maintain and improve Mediumish . Buy me a coffee Documentation"
    }, {
    "id": 2,
    "url": "http://localhost:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                                                                           Go Decorator 함수 패턴                              :               데코레이터는 Python 및 TypeScript와 같은 다른 프로그래밍 언어에서 확실히 두드러 지지만 Go에서 사용할 수는 없습니다. 실제로 특정 문제의 경우 데코레이터를 사용하는 것이 이 포스팅에서 알아볼. . . :                                                                                                                                                                       Genesis                                16 Apr 2020                                                                                                                                                                                                                                                                                                                  Go에서 환경 변수로 작업하기                              :               이 포스트에서는 Go 애플리케이션에서 환경 변수를 효과적으로 가져오고 설정하는 방법과 이후에 환경 변수를 애플리케이션 내의 기능 플래그의 기초로 사용하는 방법을 알아보겠습니다. :                                                                                                                                                                       Genesis                                15 Apr 2020                                                                                                                                                                                                                                                                                                                  Go Variadic Function 시작하기                              :               이 포스트에서는 Go에서 Variadic Functions를 살펴 보겠습니다. 자체 Go 애플리케이션에서 이러한 함수를 구현하고 사용하는 방법을 다룰 것입니다. :                                                                                                                                                                       Genesis                                14 Apr 2020                                                                                                                                                                                                                                                                                                                  Go Closures 입문                              :               이 포스트에서는 Go의 클로저를 살펴 보겠습니다. 우리는 그 뒤에있는 이론을 다룰 것이며, 자신의 Go 애플리케이션에서 그것들을 어떻게 사용할 수 있는지 살펴볼 것입니다. :                                                                                                                                                                       Genesis                                13 Apr 2020                                                                                                                                                                                                                                                                                                                  Golang에서 MySQL 사용하기                              :               이 포스트에서는 MySQL 데이터베이스에 연결하고 Go를 사용하여 기본 SQL 문을 수행하는 방법을 보여 드리겠습니다. :                                                                                                                                                                       Genesis                                12 Apr 2020                                                                                                                                                                                                                                                                                                                  Golang에서 ORM 사용하기                              :               이 포스트에서는 Go-ORM 또는 GORM을 사용하여 sqlite3 데이터베이스와 간단한 방식으로 상호 작용하는 방법을 살펴 보겠습니다. :                                                                                                                                                                       Genesis                                11 Apr 2020                                                                                                                                                                                                                                                                                                                        Go에서 네트워크 커맨드 라인 인터페이스 구축                              :               이 포스트에서는 Github(https://github. com/urfave/cli)에서 제공하는 `urfave/cli` 패키지를 사용하여 Go에서 매우 간단한 커맨드라인 인터페이스를 작성합니다. :                                                                                                                                                                       Genesis                                09 Apr 2020                                                                                                                                                                                                                                                                                                                  Golang을 사용하여 간단한 웹 서버 만들기                              :               이 포스트에서는 `net/http` 패키지를 사용하여 매우 간단한 웹 서버를 만드는데 중점을 둘 것입니다. :                                                                                                                                                                       Genesis                                08 Apr 2020                                                                                                                                                                                                                                                                                                                  Go로 RESTful API 만들기                              :               이 포스트에서는 전체 범위의 CRUD 조작을 수행할 수 있는 GET, POST, DELETE 및 PUT 엔드 포인트를 표시하는 본격적인 REST API를 빌드합니다. :                                                                                                                                                                       Genesis                                07 Apr 2020                                                                                                                                                                                                                                                                                                                  Go로 RESTful API 사용하기                              :               이 포스트에서는 go를 사용하여 이미 실행중인 RESTful API를 사용하는 방법을 보여 드리겠습니다. 현재 수십만 개에 달하는 개방형 REST API가 있으며 소비되기를 기다리고 있으며 보다 의미있는. . . :                                                                                                                                                                       Genesis                                06 Apr 2020                                                                                                                                                                                                                                                                                                                  Go Dep 사용하기                              :               이 포스트에서는 Go의 프로젝트 종속성을 관리하기 위해 이동 중에 Dep 도구를 사용하는 방법을 살펴 보겠습니다. :                                                                                                                                                                       Genesis                                05 Apr 2020                                                                                                                                                                                                                                                                                                                  Go에서 Linked Lists 다루기                              :               이 포스트에서는 Go에서 Linked Lists를 작성하고 작업할 수 있는 방법을 살펴 보겠습니다. :                                                                                                                                                                       Genesis                                04 Apr 2020                                                                                                                                                                                                                                                                                                                  Go JSON 튜토리얼                              :               이 포스트에서는 Go 애플리케이션에서 JSON으로 작업할 수 있는 방법을 포괄적으로 살펴 보겠습니다. :                                                                                                                                                                       Genesis                                03 Apr 2020                                                                                                                                                                                                                                                                                                                  Go Modules 사용하기                              :               이 포스트에서는 Go 응용 프로그램에서 Go 모듈을 사용하여 Go 응용 프로그램의 종속성에 대한 작업 방식을 단순화하는 방법을 살펴 보겠습니다. Go Modules를 사용하는 간단한 Go 응용. . . :                                                                                                                                                                       Genesis                                02 Apr 2020                                                                                                                                                                                                                                                                                                                  Go Tickers 사용하기                              :               이 포스트에서는 Go의 티커와 고유한 Go 응용 프로그램 내에서 티커를 효과적으로 사용할 수 있는 방법을 살펴 보겠습니다. :                                                                                                                                                                       Genesis                                01 Apr 2020                                                                                                                                                                                                                                                                                                                  정렬 패키지를 사용하기                              :               순서대로 항목을 정렬하는 것은 모든 프로그래머가 의심할 여지없이 경력의 한 시점에서 해야 할 일입니다. 선택할 수 있는 접근 방식과 정렬 알고리즘이 다양하지만 일반적으로 이미 구현된. . . :                                                                                                                                                                       Genesis                                31 Mar 2020                                                                                                                                                                                                                                                                                                                        Go 포인터 튜토리얼                              :               이 포스터에서는 Go의 포인터와 고유한 Go 프로그램 내에서 포인터를 사용하는 방법을 설명합니다. 모범 사례를 다루고 포인터에 대한 가장 일반적인 사용 사례를 다룰 것입니다. :                                                                                                                                                                       Genesis                                29 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 프로젝트 구조 모범 사례                              :               Go 애플리케이션이 따라야하는 구조는 다소 논쟁적인 주제입니다. 어떤 사람들은 모든 사람이 절대적으로 모든 프로젝트에 대해 잘 알려진 `golang-standards/project-layout` 구조를 따라야한다는 것을 강경합니다. :                                                                                                                                                                       Genesis                                28 Mar 2020                                                                                                                                                                                                                                                                                                                  Go init 함수                              :               Go에서 응용 프로그램을 만들 때 프로그램을 처음 시작할 때 어떤 형태의 상태를 설정할 수 있어야하는 경우가 있습니다. 여기에는 데이터베이스에 대한 연결을 만들거나 로컬로 저장된 configuration. . . :                                                                                                                                                                       Genesis                                27 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 프로그램으로 XML 파일 파싱하기                              :               이 포스팅에서는 파일 시스템에서 XML 파일을 효과적으로 읽고 Go의 `encoding/xml package`를 사용하여이 파일을 파싱하는 방법을 살펴 봅니다. 여러 개의 중첩된 xml 요소를 순회할 수 있는. . . :                                                                                                                                                                       Genesis                                26 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 프로그램으로 JSON 파일 파싱하기                              :               이번 포스팅에서는 모두 JSON 파일 또는 JSON HTTP 응답을 읽고 원하는대로 파싱할 수 있는 방법을 살펴 보겠습니다. :                                                                                                                                                                       Genesis                                25 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 프로그램으로 시스템 명령을 실행하기                              :               이번 포스팅에서는 표준 라이브러리의 `os/exec` 패키지를 살펴보고 Go 애플리케이션 내에서 시스템 명령을 성공적으로 실행하기 위해 이 패키지를 어떻게 사용할 수 있는지 살펴 보겠습니다. :                                                                                                                                                                       Genesis                                24 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 프로그램으로 콘솔 입력 읽기오기                              :               Go(GoLang) 프로그램으로 콘솔 텍스트 입력을 읽는 방법에 대한 빠르고 간단한 포스팅입니다. 이 포스트에서는 모든 사용자 입력을 읽고 사용자에게 다시 에코하는 매우 간단한 쉘의 기반을 만들. . . :                                                                                                                                                                       Genesis                                23 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 인터페이스 (Interfaces)                              :               이번 포스팅에서는 Go 프로그래밍 언어의 인터페이스를 살펴 보겠습니다. :                                                                                                                                                                       Genesis                                22 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 메서드 (Go Methods)                              :               이 포스팅에서는 우선 메서드가 무엇인지와 Go 프로그래밍 언어의 범위 내에서 그것이 어떻게 작동하는지 살펴 보겠습니다. 그런 다음 메서드과 함수의 차이점과 Go 프로그램 내에서 이상적으로 사용해야하는. . . :                                                                                                                                                                       Genesis                                21 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 함수 (Go Functions)                              :               이 포스팅을 다 읽을 무렵, 함수가 무엇인지, 자신의 프로젝트에서 어떻게 사용할 수 있는지에 대해 확실히 이해하게 되길 바랍니다. :                                                                                                                                                                       Genesis                                20 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 복합 데이터 타입 (Go Composite Types)                              :               이번 포스팅에서는 Go 프로그래밍 언어로 제공되는 다양한 복합 데이터 타입 (Composite Data Type)을 살펴 보겠습니다. :                                                                                                                                                                       Genesis                                19 Mar 2020                                                                                                                                                                                                                                                                                                                  Go 기본 타입 (Go Basic Types)                              :               이번 포스팅에서는 Go 언어에서 사용할 수 있는 모든 기본 데이터 타입을 살펴 보겠습니다. 이 튜토리얼이 끝나면 언어 내에서 사용 가능한 다양한 데이터 타입에 익숙해질 것이며. . . :                                                                                                                                                                       Genesis                                18 Mar 2020                                                                                                                                                                                                                                                                                                                  Go로 시작하기                              :               Go는 다양한 응용 프로그램을 구축할 수 있는 매우 놀라운 언어입니다. command-line 인터페이스에서 분산형 마이크로시스템 및 클라우드 플랫폼에 이르기까지 이 언어가 가지는 단순성과 동시성을 통해 많은. . . :                                                                                                                                                                       Genesis                                17 Mar 2020                                                                                                                      All Stories:                                                                                                     Go Decorator 함수 패턴              :       데코레이터는 Python 및 TypeScript와 같은 다른 프로그래밍 언어에서 확실히 두드러 지지만 Go에서 사용할 수는 없습니다. 실제로 특정 문제의 경우 데코레이터를 사용하는 것이 이 포스팅에서 알아볼 수 있는 완벽한 솔루션입니다. :                                                                               Genesis                16 Apr 2020                                                                                                                                     Go에서 환경 변수로 작업하기              :       이 포스트에서는 Go 애플리케이션에서 환경 변수를 효과적으로 가져오고 설정하는 방법과 이후에 환경 변수를 애플리케이션 내의 기능 플래그의 기초로 사용하는 방법을 알아보겠습니다. :                                                                               Genesis                15 Apr 2020                                                                                                                                     Go Variadic Function 시작하기              :       이 포스트에서는 Go에서 Variadic Functions를 살펴 보겠습니다. 자체 Go 애플리케이션에서 이러한 함수를 구현하고 사용하는 방법을 다룰 것입니다. :                                                                               Genesis                14 Apr 2020                                                                                                                                     Go Closures 입문              :       이 포스트에서는 Go의 클로저를 살펴 보겠습니다. 우리는 그 뒤에있는 이론을 다룰 것이며, 자신의 Go 애플리케이션에서 그것들을 어떻게 사용할 수 있는지 살펴볼 것입니다. :                                                                               Genesis                13 Apr 2020                                                                                                                                     Golang에서 MySQL 사용하기              :       이 포스트에서는 MySQL 데이터베이스에 연결하고 Go를 사용하여 기본 SQL 문을 수행하는 방법을 보여 드리겠습니다. :                                                                               Genesis                12 Apr 2020                                                                                                                                     Golang에서 ORM 사용하기              :       이 포스트에서는 Go-ORM 또는 GORM을 사용하여 sqlite3 데이터베이스와 간단한 방식으로 상호 작용하는 방법을 살펴 보겠습니다. :                                                                               Genesis                11 Apr 2020                                               &laquo; Prev       1        2        3        4        5        6      Next &raquo; "
    }, {
    "id": 4,
    "url": "http://localhost:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 5,
    "url": "http://localhost:4000/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 6,
    "url": "http://localhost:4000/page3/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 7,
    "url": "http://localhost:4000/page4/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 8,
    "url": "http://localhost:4000/page5/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 9,
    "url": "http://localhost:4000/page6/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 10,
    "url": "http://localhost:4000/Ch12-Go-Decorator-Function/",
    "title": "Go Decorator 함수 패턴",
    "body": "2020/04/16 - 데코레이터는 Python 및 TypeScript와 같은 다른 프로그래밍 언어에서 확실히 두드러 지지만 Go에서 사용할 수는 없습니다. 실제로 특정 문제의 경우 데코레이터를 사용하는 것이 이 포스팅에서 알아볼 수 있는 완벽한 솔루션입니다. Understanding the Decorator Pattern:  Decorators를 사용하면 기존 기능을 래핑하고 사용자 정의 기능을 추가하거나 확장 할 수 있습니다. Go에서 함수는 일급 객체로 간주되며 본질적으로 변수와 마찬가지로 전달할 수 있습니다. 매우 간단한 예를 통해 이를 실제로 살펴 보겠습니다. 123456789101112131415package mainimport (  fmt   time )func myFunc() { fmt. Println( Hello World ) time. Sleep(1 * time. Second)}func main() { fmt. Printf( Type: %T\n , myFunc)}따라서이 예에서는 myFunc라는 함수를 정의했습니다. 이 함수는 단순히 Hello World를 인쇄합니다. 그러나 main() 함수의 본문에서 fmt. Printf를 호출했으며 %T를 사용하여 두 번째 인수로 전달하는 값의 유형을 인쇄했습니다. 이 경우 myFunc를 전달하면 다음과 같이 인쇄됩니다. 12$ go run test. goType: func()그렇다면 이것이 Go 개발자에게 무엇을 의미합니까? 글쎄, 그것은 코드베이스의 다른 부분에서 함수가 전달되어 인수로 사용될 수 있다는 사실을 강조합니다. 코드베이스를 조금 더 확장하고 함수를 유일한 매개 변수로 사용하는 coolFunc() 함수를 추가하여 이를 실제로 살펴 보겠습니다. 12345678910111213141516171819202122232425package mainimport (  fmt   time )func myFunc() { fmt. Println( Hello World ) time. Sleep(1 * time. Second)}// coolFunc takes in a function// as a parameterfunc coolFunc(a func()) {  // it then immediately calls that functino a()}func main() { fmt. Printf( Type: %T\n , myFunc) // here we call our coolFunc function // passing in myFunc  coolFunc(myFunc)}이 작업을 실행하려고하면 새로운 출력에 다음과 같이 Hello World 문자열이 표시됩니다: 123$ go run test. goType: func()Hello World이제 이것은 처음에는 조금 이상하게 보일 수 있습니다. 왜 이런 식으로 하시겠습니까? 기본적으로 myFunc 호출에 추상화 계층을 추가하고 많은 value를 추가하지 않고도 코드를 복잡하게 만듭니다. A Simple Decorator: 이 패턴을 사용하여 코드베이스에 value를 더할 수 있는 방법을 살펴 보겠습니다. 원하는 경우 시작 및 종료 시간을 강조하기 위해 특정 기능의 실행에 대한 추가 로깅을 추가 할 수 있습니다. 12345678910111213141516171819202122package mainimport (   fmt    time )func myFunc() { fmt. Println( Hello World )  time. Sleep(1 * time. Second)}func coolFunc(a func()) {  fmt. Printf( Starting function execution: %s\n , time. Now())  a()  fmt. Printf( End of function execution: %s\n , time. Now())}func main() {  fmt. Printf( Type: %T\n , myFunc)  coolFunc(myFunc)}이것을 호출하면 다음과 같은 로그가 나타납니다. 12345$ go run test. goType: func()Starting function execution: 2018-10-21 11:11:25. 011873 +0100 BST m=+0. 000443306Hello WorldEnd of function execution: 2018-10-21 11:11:26. 015176 +0100 BST m=+1. 003743698보시다시피 구현을 변경하지 않고도 원래 기능을 효과적으로 포장할 수 있었습니다. 이제 이 함수가 시작된 시점과 실행이 완료된 시점을 명확하게 확인할 수 있으며 함수가 실행을 마치는데 약 1초가 걸린다는 점을 강조합니다. Real World Examples: 더 많은 명성과 재산을 위해 데코레이터를 사용하는 방법에 대한 몇 가지 예를 더 살펴 보겠습니다. 수신 요청에 특정 헤더 세트가 있는지 여부를 확인할 수 있도록 매우 간단한 http 웹 서버를 사용하여 엔드 포인트를 decorating합니다.  Go에서 간단한 REST API 작성에 대해 더 많이 배우고 싶다면 다른 기사를 확인하십시오 . Go에서 REST API 작성 123456789101112131415161718192021package mainimport (   fmt    log    net/http )func homePage(w http. ResponseWriter, r *http. Request) {  fmt. Println( Endpoint Hit: homePage )  fmt. Fprintf(w,  Welcome to the HomePage! )}func handleRequests() {  http. HandleFunc( / , homePage)  log. Fatal(http. ListenAndServe( :8081 , nil))}func main() {  handleRequests()}보시다시피, 코드에서 특별히 복잡한 것은 없습니다. single/end 포인트를 제공하는 net/http 라우터를 설정했습니다. 들어오는 요청에서 Authorized 헤더가 true로 설정되어 있는지 확인하는 매우 간단한 인증 데코레이터 기능을 추가해 보겠습니다. 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport (   fmt    log    net/http )func isAuthorized(endpoint func(http. ResponseWriter, *http. Request)) http. Handler {  return http. HandlerFunc(func(w http. ResponseWriter, r *http. Request) {    fmt. Println( Checking to see if Authorized header set. . .  )    if val, ok := r. Header[ Authorized ]; ok {      fmt. Println(val)      if val[0] ==  true  {        fmt. Println( Header is set! We can serve content! )        endpoint(w, r)      }    } else {      fmt. Println( Not Authorized!! )      fmt. Fprintf(w,  Not Authorized!! )    }  })}func homePage(w http. ResponseWriter, r *http. Request) {  fmt. Println( Endpoint Hit: homePage )  fmt. Fprintf(w,  Welcome to the HomePage! )}func handleRequests() {  http. Handle( / , isAuthorized(homePage))  log. Fatal(http. ListenAndServe( :8081 , nil))}func main() {  handleRequests()} 참고 : 이것이 REST API 보안을 처리하는 올바른 방법은 아닙니다. 이러한 목표를 달성하기 위해 JWT 또는 OAuth2를 사용하는 것이 좋습니다. 자, 이것을 분석하고 무슨 일이 일어나고 있는지 이해하려고 노력합시다! 우리는 isAuthorized()라는 새로운 데코레이터 함수를 만들었습니다. 이 함수는 원래 homePage 함수와 동일한 서명과 일치하는 함수를 받습니다. 그런 다음 http. Handler를 반환합니다. isAuthorized() 함수의 본문 내에서 Authorized 헤더의 유효성 검사 작업이 설정되어 있고 true인 새 http. HandlerFunc를 반환합니다. 자, 이것은 OAuth2 authentification/authorization의 대폭 단순화된 버전입니다. 약간의 차이가 있지만 작동 방식에 대한 일반적인 아이디어를 제공합니다. 그러나 주목해야 할 것은 기존 엔드 포인트를 decorate하고 해당 기능의 기존 구현을 변경하지 않고도 해당 엔드 포인트 주위에 인증 형식을 추가할 수 있다는 사실입니다. 이제 보호하고자 하는 새로운 엔드 포인트를 추가한다면 다음과 같이 쉽게 할 수 있습니다. 12345678910111213141516// define our newEndpoint function. Notice how, yet again,// we don't do any authentication based stuff in the body// of this functionfunc newEndpoint(w http. ResponseWriter, r *http. Request) {  fmt. Println( My New Endpoint )  fmt. Fprintf(w,  My second endpoint )}func handleRequests() {  http. Handle( / , isAuthorized(homePage)) // register our /new endpoint and decorate our // function with our isAuthorized Decorator http. Handle( /new , isAuthorized(newEndpoint))  log. Fatal(http. ListenAndServe( :8081 , nil))}이것은 코드베이스 내에서 코드를 래핑하는 것이 매우 간단한 데코레이터 패턴의 주요 이점을 강조합니다. 동일한 방법으로 새로운 인증된 엔드 포인트를 쉽게 추가할 수 있습니다. Conclusion: 이 포스팅이 데코레이터의 불가사의를 이해하고 자신의 Go 기반 프로그램에서 데코레이터 패턴을 사용하는 방법을 이해하는데 도움이 되었기를 바랍니다. 데코레이터 패턴의 이점과 기존 기능을 새로운 기능으로 감싸는데 사용할 수있는 방법에 대해 배웠습니다. 두 번째 부분은 자체 프로덕션 레벨 Go 시스템에서 이를 어떻게 사용할 수 있는지에 대한 보다 현실적인 예를 살펴 보았습니다. "
    }, {
    "id": 11,
    "url": "http://localhost:4000/Ch11-Working-With-Environment-Variables/",
    "title": "Go에서 환경 변수로 작업하기",
    "body": "2020/04/15 - 보다 복잡한 Go 기반 응용 프로그램을 구축하기 시작하면서 새로운 기능을 안전하게 도입하거나 데이터베이스 또는 브로커와 같은 자격 증명을 처리할 때 문제가 발생하기 시작합니다. 환경 변수를 사용하면 다양한 환경에서 자격 증명을 처리하고 시스템의 기능 플래그 구현을 단순화하는 등 다양한 측면을 단순화 할 수 있습니다. 이 튜토리얼에서는 다음을 다룰 것입니다.  Go 애플리케이션에서 환경 변수를 효과적으로 가져오고 설정하는 방법 이후에 환경 변수를 애플리케이션 내의 기능 플래그의 기초로 사용하는 방법Handling Credentials: Go에서 분산 시스템을 작성하는 경우 구성에 관한 최상의 방법은 환경에 저장하는 것입니다. 이 방법을 사용하면 개발 데이터베이스 자격 증명이 이미 환경에 주입된 개발 서버인 응용 프로그램 버전을 실제로 쉽게 배포할 수 있습니다. 개발 노력에 만족하면 추가 번거로움 없이 이미 환경에 주입된 프로덕션 데이터베이스 자격 증명이 있는 프로덕션 서버에 동일한 응용 프로그램 복사본을 배포할 수 있습니다.  참고 - 클라우드 네이티브 애플리케이션 개발시 준수해야하는 12가지 요소에 대한 자세한 내용을 읽을 수 있습니다 - III. Config Reading Environment Variables: Go를 사용하면 os 패키지를 사용하고 환경 변수의 문자열 이름을 전달하는 os. Getenv()를 호출하여 환경 변수를 읽을 수 있습니다. 머신에서 DATABASE_PASS라는 환경 변수를 설정한 다음 애플리케이션에서 읽고 원하는 경우 데이터베이스에 연결하는데 사용할 수 있습니다. 1$ export DATABASE_PASS=unicorns 참고 - MacOS를 사용하여이 자습서를 작성하고 있습니다. Windows를 사용하는 경우 set DATABASE_PASS = unicorns를 사용해야 할 수도 있습니다. 다음으로 이 DATABASE_PASS에서 읽을 수있는 Go 프로그램을 작성해 보겠습니다. 12345678910111213package mainimport (   fmt    os )func main() {  fmt. Println( Reading Environment Variable )  var databasePass string  databasePass = os. Getenv( DATABASE_PASS )  fmt. Printf( Database Password: %s\n , databasePass)}이제 이것을 실행하면 다음과 같은 결과가 나타납니다. 123$ go run main. goReading Environment VariableDatabase Password: unicorns놀랍게도 응용 프로그램은이 환경 변수를 성공적으로 선택하고 fmt. Printf에 대한 간단한 호출을 사용하여 인쇄할 수 있었습니다. Setting Environment Variables: Go는 또한 원하는 경우 환경 변수를 설정할 수 있습니다. os 패키지를 다시 활용하고 os. Setenv()를 호출하면 됩니다. 1234567891011121314151617181920package mainimport (   fmt    os )func main() {  fmt. Println( Reading Environment Variable )  var databasePass string  databasePass = os. Getenv( DATABASE_PASS )  fmt. Printf( Database Password: %s\n , databasePass)  err := os. Setenv( DATABASE_PASS ,  newunicorns )  if err != nil {    fmt. Println(err)  }  databasePass = os. Getenv( DATABASE_PASS )  fmt. Printf( Database Password: %s\n , databasePass)}계속 진행하면 환경 변수 변경 사항이 적용됩니다. 1234$ go run main. goReading Environment VariableDatabase Password: unicornsDatabase Password: newunicorns 참고 - 이 작업을 다시 실행하면 유니콘이 다시 DATABASE_PASS의 원래 값으로 선택됩니다. 자식 프로세스는 부모 프로세스의 환경 변수를 변경할 수 없기 때문입니다. 모든 변경 사항은 Go 프로그램에만 적용됩니다. Feature Flags: Go 프로그램 내에서 환경 변수를 흥미롭게 사용하는 기능은 Feature Flags 또는 Feature Toggles입니다. 이러한 feature flags는 본질적으로 배포시 유연성을 제공하여 문제 발생시 새로운 features를 끄고 이전 features로 되돌릴 수 있습니다.  참고 - 이전에 feature Flags/Toggles에 대해 들어 보지 못한 경우 Martin Fowler의 Feature Flags/Toggles에서이 기사를 확인하는 것이 좋습니다. 간단한 REST API를 예로 들어 보겠습니다: 123456789101112131415161718192021222324252627package mainimport (   fmt    log    net/http    os )func homePage(w http. ResponseWriter, r *http. Request) {  if os. Getenv( FEATURE_TOGGLE ) ==  TRUE  {    fmt. Println(os. Getenv( FEATURE_TOGGLE ))    fmt. Fprintf(w,  Exciting New Feature )  } else {    fmt. Println(os. Getenv( FEATURE_TOGGLE ))    fmt. Fprintf(w,  existing boring feature )  }}func handleRequests() {  http. HandleFunc( / , homePage)  log. Fatal(http. ListenAndServe( :8081 , nil))}func main() {  handleRequests()}FEATURE_TOGGLE 환경 변수를 TRUE로 설정하여 이 응용 프로그램을 시작할 수 있습니다. 이 기능은 “Exciting New Feature”를 활성화하지만 프로덕션 환경에서 이 새 feature를 실행한 후에 문제가 발생하면 프로세스를 종료하고 환경 변수를 변경할 수 있습니다. 응용 프로그램을 빠르게 다시 시작하기 전에 FALSE로 설정하십시오. 분산 시스템에서 이 downtime은 애플리케이션 인스턴스가 다운된 상태에서 로드 밸런서 그룹에서 제거된 다음 다시 로드 밸런서 그룹에 다시 추가되는 것을 볼 수 있습니다. Setup Of Environment Variables: 보다 복잡한 응용 프로그램에서는 응용 프로그램을 시작하기 전에 수백 가지의 다른 환경 변수를 설정해야하는 경우가 있습니다. 이제 이러한 환경 변수를 관리할 때 여러 가지 기술이 있습니다. 안타깝게도 이는 “fuzzy” 답변을 제공하는 것입니다. 조직마다 보안 기준이 다르기 때문에 완벽하게 유효한 솔루션이 적합하지 않습니다.  참고 – 자격 증명 보안은 올바른 자격을 얻기 위해 많은 시간과 노력이 필요합니다. 이것들은 단지 제안일 뿐이지만, 귀하의 팀에 적합한 솔루션을 찾아보아야 합니다.  git-crypt - AGWA/git-crypt - git repo에서 파일의 투명한 암호화/암호 해독을 허용합니다. 이를 통해 bash 파일을 암호화하여 구성을 설정하고 실행할 때 해독할 수 있습니다.  AWS SSM - https://aws. amazon. com/secrets-manager/-AWS 관련 키트로 작업하는 경우 서비스를 통해 자격 증명을 관리할 수 있습니다.  Within your CI/CD Tool - 예 - https://travis-ci. org/ - 서비스에 환경 자격 증명을 한 번 주입하고 수동 단계만으로 빌드 작업에 자동으로 주입할 수 있도록합니다. 이것들은 몇 가지 잠재적 인 제안 일뿐입니다. 프로덕션 환경에서 이를 안전한 방식으로 처리하는 방법에 대한 정보를 제공하기를 바랍니다. Conclusion: 따라서 이 포스트에서는 Go에서 환경 변수 읽기 및 쓰기와 이러한 환경 변수를 사용하여 기능 플래그 또는 애플리케이션 내 기능 토글을 구현하는 방법에 대해 설명했습니다. "
    }, {
    "id": 12,
    "url": "http://localhost:4000/Ch10-Go-Variadic-Function/",
    "title": "Go Variadic Function 시작하기",
    "body": "2020/04/14 - 이 포스트에서는 Go에서 Variadic Functions를 살펴 보겠습니다. 자체 Go 애플리케이션에서 이러한 함수를 구현하고 사용하는 방법을 다룰 것입니다. Variadic Functions: 함수에 필요한 문자열 인수의 수를 모르는 경우가 있습니다. 이곳에서 가변 기능이 작동합니다. Variadic 함수를 사용하면 임의의 수의 인수를 취하는 함수를 정의할 수 있습니다. 이렇게하면 입력 길이의 모든 가능한 변형에 대해 코드를 작성하지 않아도되며 이 개념은 Python 및 Java와 같은 다양한 언어로 전송됩니다. 12345678910111213package mainimport (  fmt )func myVariadicFunction(args . . . string) { fmt. Println(args)}func main() { myVariadicFunction( hello ,  world )}이를 실행하려고하면 fmt. Println() 호출이 Hello와 world를 모두 포함하는 문자열 배열을 인쇄한다는 것을 알 수 있습니다. 12$ go run main. go[hello world] 참고 - Variadic 함수는 문자열로 제한되지 않으며 복합 또는 기본 유형의 모든 변형을 사용할 수 있습니다. Production Examples: 프로덕션 Go 코드에서 이에 대한 예를 살펴 보겠습니다. Println()은 가장 잘 알려진 가변 함수의 좋은 예입니다. 123456// Println formats using the default formats for its operands and writes to standard output. // Spaces are always added between operands and a newline is appended. // It returns the number of bytes written and any write error encountered. func Println(a . . . interface{}) (n int, err error) {  return Fprintln(os. Stdout, a. . . )} 참고 – 이 예에서는 임의의 수의 interface{} 인수를 사용합니다. Conclusion: 따라서 이 포스트에서는 Go의 가변 함수를 성공적으로 다룰 수 있었습니다. 우리는 그것이 무엇이며, 자신의 Go 프로그램 내에서 명성과 재산으로 사용될 수 있는 방법을 다뤘습니다. "
    }, {
    "id": 13,
    "url": "http://localhost:4000/Ch09-Go-Closures/",
    "title": "Go Closures 입문",
    "body": "2020/04/13 - 이 포스트에서는 Go의 클로저를 살펴 보겠습니다. 우리는 그 뒤에있는 이론을 다룰 것이며, 자신의 Go 애플리케이션에서 그것들을 어떻게 사용할 수 있는지 살펴볼 것입니다. Closures - The Theory: 이론에 대해 알아 보겠습니다. 함수를 일급 객체로 지원하는 모든 프로그래밍 언어 내에서 클로저를 만들고 사용할 수 있습니다. Go는 그런 언어 중 하나입니다. 그렇지 않은 언어에는 이 포스팅이 의미가 없습니다. 따라서 클로저에 대한 기술적 정의는 클로저는 일급 함수로 언어에서 어휘적 범위가 지정된 이름 바인딩을 구현하는 기술입니다. - 위키백과 걱정하지 마세요. 처음 읽을 때는 누구든 머리가 약간 아프고 생각이 필요합니다. 일반인의 관점에서 closure는 그것의 body와 함께 배치되는 변수를 참조할 수 있는 함수 값입니다.  참고 - 클로저와 클로저라고 일반적으로 잘못 알려진 익명 함수의 뚜렷한 차이점에 주의해야합니다. 익명 함수에 대한 자세한 내용은 다음을 참조하십시오. Go Anonymous Functions A Simple Example:  main. go 1234567891011121314151617package mainimport  fmt func getLimit() func() int {  limit := 10  return func() int {    limit -= 1    return limit  }}func main() {  limit := getLimit()  fmt. Println(limit())  fmt. Println(limit())}이제 이것을 실행하면 다음과 같은 결과가 나타납니다.  go run main. go 1298그러나 이것이 왜 중요한가? 이 limit 변수는 할당된 limit에 묶여 있습니다. getLimit()을 바인드하여 바로 아래에 limit2를 지정하면 고유 한 상태가됩니다.  main. go 123456789101112131415161718192021222324package mainimport  fmt func getLimit() func() int {  limit := 10  return func() int {    limit -= 1    return limit  }}func main() {  limit := getLimit()  fmt. Println(limit()) // 9  fmt. Println(limit()) // 8  limit2 := getLimit()  fmt. Println(limit2()) // 9  fmt. Println(limit2()) // 8  fmt. Println(limit()) // 7}이것을 실행하면 다음과 같은 결과가 나타납니다.  $go run main. go 1234598987놀랍게도 Go에서 직접 closure 인스턴스를 만들었습니다. 결론: 이 포스트에서는 클로저의 기본 이론과 자신의 Go 프로그램 내에서 클로저를 사용하는 방법에 대해 설명했습니다. "
    }, {
    "id": 14,
    "url": "http://localhost:4000/Ch08-Golang-MySQL-Tutorial/",
    "title": "Golang에서 MySQL 사용하기",
    "body": "2020/04/12 - Golang 학습 과정을 계속함에 따라 어떤 형태의 데이터베이스와 상호 작용해야하는 것은 거의 불가피합니다. 이 포스트에서는 MySQL 데이터베이스에 연결하고 Go를 사용하여 기본 SQL 문을 수행하는 방법을 보여 드리겠습니다. Why MySQL?: MySQL은 현재 개발자가 사용할 수있는 가장 잘 알려진 잘 사용되는 데이터베이스 기술 중 하나입니다. 주변에는 절대적으로 거대한 커뮤니티가 있으며 Wordpress의 기본 데이터베이스 기술로 웹의 절반을 강화할 수 있습니다. MySQL 인스턴스를 로컬로 돌리는 것은 매우 쉬우므로 적절한 애플리케이션을 구축하기에 완벽합니다.  참고 - 기술 선택은 인기를 기반으로하지 않아야하며 CockroachDB 또는 NoSQL 데이터베이스와 같은 대안을 고려해야하는 시나리오가 있을 수 있습니다. Video Tutorial: Text Tutorial: 이를 위해 https://github. com/go-sql-driver/mysql 을 MySQL 드라이버로 사용합니다. Go-SQL-Driver는 가볍고 빠른 MySQL 드라이버로 TCP/IPv4, TCP/IPv6, Unix domain sockets 또는 사용자 지정 프로토콜을 통한 연결을 지원하며 끊어진 연결을 자동으로 처리합니다.  Github Repo: go-sql-driver/mysql Connection Pooling: 고성능 데이터베이스 응용 프로그램을 구축하는 경우 연결 풀링이 반드시 필요합니다. 고맙게도 이 포스트의 기초로 사용할 오픈 소스 패키지는 database/SQL 표준 패키지를 사용하므로 자동 연결 풀링 기능이 있습니다. 이는 기본적으로 데이터베이스를 쿼리할 때마다 응용 프로그램 시작시 설정된 연결 풀에서 연결을 사용하고 있음을 의미합니다. 이러한 연결은 계속해서 재사용되며, 따라서 쿼리를 수행할 때마다 새 연결을 작성하여 삭제하지 않음을 의미합니다. Implementation: 먼저 로컬 머신에 설정한 데이터베이스에 연결한 다음 기본적인 삽입 및 선택 명령문을 수행합니다. Connecting to a MySQL database: 새로운 main. go 파일을 만들어 봅시다. 이 과정에서 몇 개의 패키지를 가져와서 이미 실행중인 로컬 데이터베이스에 대한 간단한 연결을 설정합니다. 이 포스트에서는 phpmyadmin을 사용하여 MySQL을 시작했으며 test라는 데이터베이스를 만들어 테이블에 연결하고 테이블을 만듭니다. sql. Open을 사용하여 데이터베이스에 연결하고 자동 연결 풀을 설정하면 db 또는 err을 처리할 수 있습니다. 1234567891011121314151617181920212223242526package mainimport (   fmt    database/sql   _  github. com/go-sql-driver/mysql )func main() {  fmt. Println( Go MySQL Tutorial )  // Open up our database connection.   // I've set up a database on my local machine using phpmyadmin.   // The database is called testDb  db, err := sql. Open( mysql ,  username:password@tcp(127. 0. 0. 1:3306)/test )  // if there is an error opening the connection, handle it  if err != nil {    panic(err. Error())  }  // defer the close till after the main function has finished  // executing  defer db. Close()}Performing Basic SQL Commands: 이제 연결을 만들었으므로 데이터베이스에 쿼리를 제출해야합니다. 고맙게도 db. Query(sql)를 사용하면 원하는 SQL 명령을 수행할 수 있습니다. 쿼리 문자열을 구성하여 매개 변수로 전달하면됩니다. 12345678910111213141516171819202122232425262728293031323334353637package mainimport (   fmt    database/sql   _  github. com/go-sql-driver/mysql )func main() {  fmt. Println( Go MySQL Tutorial )  // Open up our database connection.   // I've set up a database on my local machine using phpmyadmin.   // The database is called testDb  db, err := sql. Open( mysql ,  root:password1@tcp(127. 0. 0. 1:3306)/test )  // if there is an error opening the connection, handle it  if err != nil {    panic(err. Error())  }  // defer the close till after the main function has finished  // executing  defer db. Close()  // perform a db. Query insert  insert, err := db. Query( INSERT INTO test VALUES ( 2, 'TEST' ) )  // if there is an error inserting, handle it  if err != nil {    panic(err. Error())  }  // be careful deferring Queries if you are using transactions  defer insert. Close()}Populating Structs from Results: 데이터베이스에서 결과 세트를 검색하는 것은 모두 훌륭하지만 좋은 결과를 읽거나 기존 구조체를 채워서 파싱하고 쉽게 수정할 수 있어야합니다. 여러 행을 구문 분석하기 위해 . Scan (args …) 메소드를 사용하여 여러 인수를 가져와 복합 객체를 채울 수 있습니다. 1234567/* * Tag. . . - a very simple struct */type Tag struct {  ID  int  `json: id `  Name string `json: name `}12345678910111213141516171819202122232425262728func main() {  // Open up our database connection.   db, err := sql. Open( mysql ,  root:pass1@tcp(127. 0. 0. 1:3306)/tuts )  // if there is an error opening the connection, handle it  if err != nil {    log. Print(err. Error())  }  defer db. Close()  // Execute the query  results, err := db. Query( SELECT id, name FROM tags )  if err != nil {    panic(err. Error()) // proper error handling instead of panic in your app  }  for results. Next() {    var tag Tag    // for each row, scan the result into our tag composite object    err = results. Scan(&amp;tag. ID, &amp;tag. Name)    if err != nil {      panic(err. Error()) // proper error handling instead of panic in your app    }        // and then print out the tag's Name attribute    log. Printf(tag. Name)  }}이 예에서는 태그 데이터베이스에서 2 개의 열을 검색한 다음 . Scan을 사용하여 태그 객체를 채웁니다.  참고 - 데이터베이스에서 3개의 필드를 검색하고 스캔에 2개의 매개 변수만있는 경우 실패합니다. 그들은 정확히 일치해야합니다. Querying a Single Row: 이번에 하나의 행을 쿼리하고 ID를 가지고 구조체를 채우고 싶다고 가정 해보십시오. 우리는 그렇게 할 수 있습니다: 123456789var tag Tag// Execute the queryerr = db. QueryRow( SELECT id, name FROM tags where id = ? , 2). Scan(&amp;tag. ID, &amp;tag. Name)if err != nil {  panic(err. Error()) // proper error handling instead of panic in your app}log. Println(tag. ID)log. Println(tag. Name)Conclusion: 이 포스트에서는 MySQL에 대한 연결을 설정한 다음 해당 데이터베이스에 대한 간단한 쿼리를 수행하고 반환된 응답을 구조체 또는 구조체 배열에 마샬링했습니다. 이를통해 더 나아가 MySQL을 기반으로 고유한 Go 애플리케이션을 구축하는데 필요한 모든 것을 제공할 수 있기를 바랍니다. Recommanded Reading::  Creating a RESTful JSON api with Go"
    }, {
    "id": 15,
    "url": "http://localhost:4000/Ch07-Golang-ORM/",
    "title": "Golang에서 ORM 사용하기",
    "body": "2020/04/11 - 이 포스트에서는 Go-ORM 또는 GORM을 사용하여 sqlite3 데이터베이스와 간단한 방식으로 상호 작용하는 방법을 살펴 보겠습니다. ORM 또는 Object Relationship Manager는 개발자와 기본 데이터베이스 기술 간의 중개자 역할을합니다. 그것들은 우리가 평소와 같이 본질적으로 객체를 다루고 복잡한 SQL 문을 만들지 않고도 이러한 객체를 저장할 수 있도록합니다. SQL로 작업하고 싶지 않지만 데이터베이스가 필요한 시나리오에서 코드베이스의 복잡성을 효과적으로 줄입니다. Video Tutorial: Installation: jinzhu/gorm을 설치하려면 다음 go get 명령을 수행해야합니다. 1go get -u github. com/jinzhu/gorm이 작업을 마친 후에는 jinzhu/gorm을 모든 Go 기반 프로젝트로 가져올 수 있습니다. A Simple Example: 예를 들어 특정 API 엔드 포인트에 도달했을 때 데이터베이스에 새 사용자 및 이메일을 저장하는 go REST API를 작성하려고한다고 가정하십시오. 우리는 다음과 같이 사용자를 go struct로 기술할 수 있습니다. 123456// Our User Structtype User struct {  gorm. Model  Name string  Email string}사용자 모델을 정의한 후에는 새로운 사용자를 sqlite3 데이터베이스에 저장할 수 있는 API 엔드 포인트를 노출할 수 있습니다.  참고 - 고유한 Go 기반 REST API를 개발할 수 있는 방법을 알고 싶다면 다른 Go 포스트: Go에서 RESTful API 빌드하기를 확인하십시오. Our API: 그래서 우리는 4개의 서로 다른 CRUD 엔드 포인트를 특징으로하는 매우 간단한 API를 만들 것입니다. 모든 사용자를 반환하고 새 사용자를 추가하며 사용자를 삭제하고 사용자를 업데이트합니다. 새로운 GORM의 도움으로 표준 원시 SQL 라우트를 중단한 경우 이러한 엔드 포인트 생성이 이전보다 훨씬 간단 해졌습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport (   fmt    log    net/http    github. com/gorilla/mux )func allUsers(w http. ResponseWriter, r *http. Request) {  fmt. Fprintf(w,  All Users Endpoint Hit )}func newUser(w http. ResponseWriter, r *http. Request) {  fmt. Fprintf(w,  New User Endpoint Hit )}func deleteUser(w http. ResponseWriter, r *http. Request) {  fmt. Fprintf(w,  Delete User Endpoint Hit )}func updateUser(w http. ResponseWriter, r *http. Request) {  fmt. Fprintf(w,  Update User Endpoint Hit )}func handleRequests() {  myRouter := mux. NewRouter(). StrictSlash(true)  myRouter. HandleFunc( /users , allUsers). Methods( GET )  myRouter. HandleFunc( /user/{name} , deleteUser). Methods( DELETE )  myRouter. HandleFunc( /user/{name}/{email} , updateUser). Methods( PUT )  myRouter. HandleFunc( /user/{name}/{email} , newUser). Methods( POST )  log. Fatal(http. ListenAndServe( :8081 , myRouter))}func main() {  fmt. Println( Go ORM Tutorial )  // Handle Subsequent requests  handleRequests()}그런 다음 go run main. go를 실행하여 이 새로운 API를 시작할 수 있습니다. 이 API는 ORM 기반 솔루션을 구축할 기반을 나타냅니다. SQLite3 Database Creation and Automatic Schema Migration: 프로젝트의 다음 단계는 데이터베이스를 만드는 것입니다. 이 포스트의 목적상, 사용 및 설정이 쉬운 sqlite3 데이터베이스를 사용하려고합니다.  참고 – 방언을 전환하여 GORM을 사용하여 다른 데이터베이스 기술을 상당히 쉽게 사용할 수 있습니다. GORM을 사용하여 db. AutoMigrate(&amp;User{})를 호출하여 데이터베이스 내에 User 테이블을 자동으로 작성할 수 있습니다. 이것은 테이블 생성 SQL 스크립트를 작성하는 번거로움을 덜어줍니다. 123456789101112131415161718192021// our initial migration functionfunc initialMigration() {  db, err := gorm. Open( sqlite3 ,  test. db )  if err != nil {    fmt. Println(err. Error())    panic( failed to connect database )  }  defer db. Close()  // Migrate the schema  db. AutoMigrate(&amp;User{})}func main() {  fmt. Println( Go ORM Tutorial )  // Add the call to our new initialMigration function  initialMigration()  handleRequests()}Updating our All Users Endpoint: allUsers() 함수 내에서 기본적으로 데이터베이스 내의 모든 User 레코드를 쿼리한 다음이를 JSON으로 인코딩하여 응답으로 리턴하려고합니다. db. Find(&amp; users)를 호출하여 데이터베이스 내의 모든 users를 쿼리할 수 있습니다. 12345678910111213func allUsers(w http. ResponseWriter, r *http. Request) {  db, err := gorm. Open( sqlite3 ,  test. db )  if err != nil {    panic( failed to connect database )  }  defer db. Close()  var users []User  db. Find(&amp;users)  fmt. Println( {} , users)  json. NewEncoder(w). Encode(users)}Updating our New User Endpoint: 이제 새로운 사용자를 데이터베이스에 삽입 할 수 있도록 newUser() 함수를 업데이트하려고 합니다. API에 대한 요청의 검색어 매개 변수에서 사용자 이름과 이메일을 모두 parsing 해야합니다. 엔드 포인트의 경로 매개 변수를 parsing한 다음 이러한 경로 매개 변수를 사용하여 새 User 오브젝트를 채우고 다음과 같이 db. Create(&amp;User{Name: name, Email: email})을 호출하여 sqlite 데이터베이스에 삽입합니다. 그러면 다음과 같이 나타낼 수 있습니다: 12345678910111213141516func newUser(w http. ResponseWriter, r *http. Request) {  fmt. Println( New User Endpoint Hit )  db, err := gorm. Open( sqlite3 ,  test. db )  if err != nil {    panic( failed to connect database )  }  defer db. Close()  vars := mux. Vars(r)  name := vars[ name ]  email := vars[ email ]  db. Create(&amp;User{Name: name, Email: email})  fmt. Fprintf(w,  New User Successfully Created )}Our Delete User Endpoint: deleteUser() 함수는 경로 매개 변수를 통해 전달된 동일한 name과 일치하는 사용자를 삭제합니다. 다소 기본적이며 데이터베이스에 동일한 사용자를 가진 사용자가 두 명 이상있는 경우를 처리하지 않지만 이 프로젝트에서 좋은 예를 제공합니다. 12345678910111213141516func deleteUser(w http. ResponseWriter, r *http. Request) {  db, err := gorm. Open( sqlite3 ,  test. db )  if err != nil {    panic( failed to connect database )  }  defer db. Close()  vars := mux. Vars(r)  name := vars[ name ]  var user User  db. Where( name = ? , name). Find(&amp;user)  db. Delete(&amp;user)  fmt. Fprintf(w,  Successfully Deleted User )}Our Update User Endpoint: 데이터베이스 내에서 기존 사용자를 업데이트해야 할 경우 GORM을 사용하여 훨씬 쉽게 수행할 수 있습니다. 기본적으로 고유 이름을 사용하여 지정된 사용자를 검색해야합니다. 이 사용자가 있으면 일반적으로 표준 go 객체와 마찬가지로 User 객체 만 업데이트하면됩니다. 오브젝트와 갱신 사항에 만족하면 db. Save(&amp;user)를 호출하여 변경 사항을 데이터베이스에 저장하십시오. 12345678910111213141516171819func updateUser(w http. ResponseWriter, r *http. Request) {  db, err := gorm. Open( sqlite3 ,  test. db )  if err != nil {    panic( failed to connect database )  }  defer db. Close()  vars := mux. Vars(r)  name := vars[ name ]  email := vars[ email ]  var user User  db. Where( name = ? , name). Find(&amp;user)  user. Email = email  db. Save(&amp;user)  fmt. Fprintf(w,  Successfully Updated User )}Full Source Code: 이 프로젝트의 전체 소스 코드를 원하면 이 gist를 확인하십시오: https://gist. github. com/elliotforbes/e241eaa8cc9d7bf3ec75b333e891d422 "
    }, {
    "id": 16,
    "url": "http://localhost:4000/Ch06-Writing-A-Twitter-Bot/",
    "title": "Ch06 Writing A Twitter Bot",
    "body": "2020/04/10 - "
    }, {
    "id": 17,
    "url": "http://localhost:4000/Ch05-Building-a-Network-Command-Line/",
    "title": "Go에서 네트워크 커맨드 라인 인터페이스 구축",
    "body": "2020/04/09 -  Table Of Contents:           전제 조건          인기있는 프로젝트          비디오 튜토리얼          시작하기          코드로 들어가기          우리의 첫 번째 명령          IP 주소 검색          CNAME 검색          MX 레코드 조회          CLI 구축          결론      이 포스트에서는 Github에서 제공하는 urfave/cli 패키지를 사용하여 Go에서 매우 간단한 커맨드라인 인터페이스를 작성합니다. 최근 다양한 호스팅 제공 업체에서 하나 또는 두 개의 도메인 마이그레이션을 해왔으며 웹 사이트의 네임 서버, CNAME, IP 주소 및 웹 사이트와 같은 것을 쿼리하는데 사용할 수 있는 도구나 프로그램을 구축하는 것을 생각해왔습니다. 이 튜토리얼의 전반적인 목표는 네트워크 모니터링, 이미지 조작 등과 같은 다양한 다른 작업을 수행할 수 있는 고유 한 CLI를 구축할 수 있는 방법에 대한 아이디어를 제공하는 것입니다.  참고 - 이 포스트의 전체 코드는 TutorialEdge/Go/go-cli-tutorial에서 찾을 수 있습니다.   전제 조건:  개발 머신에 Go 버전 1. 11 이상이 설치되어 있어야합니다.   인기있는 프로젝트 : Golang은 엄청난 인기를 얻고 있으며 Hashicorp와 같은 대기업은 다양한 도구와 시스템에 언어를 채택하고 있습니다. 그리고 정당한 이유로 Go의 디자인은 이러한 스타일의 응용 프로그램에 매우 적합하며 모든 주요 플랫폼에 대한 바이너리 실행 파일을 쉽게 크로스 컴파일하는 기능은 큰 이점입니다.   비디오 튜토리얼 : 비디오 매체를 통한 학습을 선호하는 경우 여기에서이 튜토리얼을 확인하십시오.    시작하기: 컴퓨터에 go-cli/라는 이름의 새 디렉토리를 만들겠습니다. 프로젝트에 다음과 같은 디렉토리 구조를 만들 것입니다. 123456go-cli/- pkg/- cmd/my-cli/- vendor/- README. md- . . .  참고 - 이 구조는 Github에서 널리 사용되는 Go 프로젝트 레이아웃 가이드를 따릅니다.   코드로 들어가기: 기본 프로젝트 구조가 완성되었으므로 응용 프로그램 작업을 시작할 수 있습니다. 우선 새 cmd/my-cli/ 디렉토리에 cli. go라는 새 파일이 필요합니다. 이를 간단한 Hello World 유형의 응용 프로그램으로 채우고 이를 기반으로 삼을 것입니다. 12345678910// cmd/my-cli/cli. gopackage mainimport (  fmt )func main() { fmt. Println( Go CLI v0. 01 )}그런 다음 다음을 입력하여 프로젝트의 루트 디렉토리에서 이를 실행할 수 있습니다. 12➜ go run cmd/my-cli/cli. goGo CLI v0. 01훌륭합니다. 새로운 CLI를 만들었습니다. 이제 몇 가지 명령을 추가하고 유용하게 사용할 수 있는 방법을 살펴 보겠습니다.   우리의 첫 번째 명령: urfave/cli 패키지를 사용할 예정이므로 이 패키지를 사용하려면 로컬로이 패키지를 다운로드 해야합니다. 간단한 go get 명령을 통해 다음과 같이 할 수 있습니다. 1$ go get github. com/urfave/cli필요한 패키지가 준비되었으므로 cli. go 파일을 업데이트하여 이 패키지를 사용하고 새로운 CLI 응용 프로그램을 만들어 보겠습니다. 1234567891011121314// cmd/my-cli/cli. goimport (  log   os   github. com/urfave/cli )func main() { err := cli. NewApp(). Run(os. Args) if err != nil {  log. Fatal(err) }}지금 실행하면 프로그램 응답을 구체화하고 버전, cli 사용법 및 다양한 명령을 추가할 수 있습니다. 12345678910111213141516➜ go run cmd/my-cli/cli. goNAME:  cli - A new cli applicationUSAGE:  cli [global options] command [command options] [arguments. . . ]VERSION:  0. 0. 0COMMANDS:   help, h Shows a list of commands or help for one commandGLOBAL OPTIONS:  --help, -h   show help  --version, -v print the version놀랍게도, 이것은 단지 부차적인 프로젝트가 아니라 보다 세련된 프로젝트처럼 보이기 시작했습니다. 이제 우리 자신의 Command를 추가 할 수 있습니다. 이러한 각 명령은 테스트 중 하나와 일치하므로 하나의 명령이 있습니다. ns는 트리거되고 url과 함께 제공될 때 해당 호스트의 Name 서버를 검색하고 조회합니다. 마지막 명령 목록은 다음과 같습니다.  ns - 이름 서버를 검색합니다 cname - 주어진 호스트에 대한 CNAME을 조회합니다 mx - 주어진 호스트에 대한 메일 교환 레코드를 조회합니다 ip - 주어진 호스트의 IP 주소를 검색합니다. 훌륭하고 간단합니다. 첫 번째 명령을 만들어 시작하겠습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport (   fmt    log    net    os    github. com/urfave/cli )func main() {  app := cli. NewApp()  app. Name =  Website Lookup CLI   app. Usage =  Let's you query IPs, CNAMEs, MX records and Name Servers!   // We'll be using the same flag for all our commands  // so we'll define it up here  myFlags := []cli. Flag{    &amp;cli. StringFlag{      Name:  host ,      Value:  tutorialedge. net ,    },  }  // we create our commands  app. Commands = []*cli. Command{    {      Name:  ns ,      Usage:  Looks Up the NameServers for a Particular Host ,      Flags: myFlags,      // the action, or code that will be executed when      // we execute our `ns` command      Action: func(c *cli. Context) error {        // a simple lookup function        ns, err := net. LookupNS(c. String( host ))        if err != nil {          return err        }        // we log the results to our console        // using a trusty fmt. Println statement        for i := 0; i &lt; len(ns); i++ {          fmt. Println(ns[i]. Host)        }        return nil      },    },  }  // start our application  err := app. Run(os. Args)  if err != nil {    log. Fatal(err)  }}그런 다음 다음을 입력하여 이를 실행할 수 있습니다. 1$ go run cmd/my-cli/cli. go ns --host tutorialedge. net그런 다음 내 사이트의 이름 서버를 반환하고 터미널에서 인쇄해야합니다. CLI 내에서 새 명령을 사용하는 방법을 정확하게 보여주는 help 명령을 실행할 수도 있습니다.   IP 주소 검색 : 결과를 인쇄하는 방법을 제외하고 모든 명령 정의는 프로그램 내에서 실제로 비슷하게 보입니다. net. LookupIP() 함수는 IP 주소 조각을 반환하므로 이를 좋은 방식으로 인쇄하려면 이러한 주소를 반복해야합니다. 123456789101112131415{  Name:  ip ,  Usage:  Looks up the IP addresses for a particular host ,  Flags: myFlags,  Action: func(c *cli. Context) error {    ip, err := net. LookupIP(c. String( host ))    if err != nil {      fmt. Println(err)    }    for i := 0; i &lt; len(ip); i++ {      fmt. Println(ip[i])    }    return nil  },},  CNAME 검색 : 그런 다음 cname 명령을 추가하여 net. LookupCNAME() 함수를 전달된 호스트와 함께 사용하고 단일 CNAME 문자열을 반환하면 인쇄할 수 있습니다. 12345678910111213{  Name:  cname ,  Usage:  Looks up the CNAME for a particular host ,  Flags: myFlags,  Action: func(c *cli. Context) error {    cname, err := net. LookupCNAME(c. String( host ))    if err != nil {      fmt. Println(err)    }    fmt. Println(cname)    return nil  },},  MX 레코드 조회 : 마지막으로, 우리는 주어진 호스트에 대한 메일 교환 레코드를 쿼리 할 수 있기를 원합니다. net. LookupMX() 함수를 사용하여 호스트에 전달하면됩니다. 그러면 IP와 같이 mx 레코드 조각이 반환됩니다. IP 레코드와 같이 인쇄하려면 다음과 같이 반복해야합니다. 123456789101112131415{  Name:  mx ,  Usage:  Looks up the MX records for a particular host ,  Flags: myFlags,  Action: func(c *cli. Context) error {    mx, err := net. LookupMX(c. String( host ))    if err != nil {      fmt. Println(err)    }    for i := 0; i &lt; len(mx); i++ {      fmt. Println(mx[i]. Host, mx[i]. Pref)    }    return nil  },},  CLI 구축 : 이제 기본 CLI를 설치하고 실행 했으므로 이제 분노로 사용할 수 있도록 CLI를 빌드해야합니다. 1$ go build cmd/my-cli/cli. go다음과 같이 실행할 수있는 cli 실행 파일을 컴파일해야합니다. 1234567891011121314151617181920$ . /cli helpNAME:  Website Lookup CLI - Let's you query IPs, CNAMEs, MX records and Name Servers!USAGE:  cli [global options] command [command options] [arguments. . . ]VERSION:  0. 0. 0COMMANDS:   ns    Looks Up the NameServers for a Particular Host   cname  Looks up the CNAME for a particular host   ip    Looks up the IP addresses for a particular host   mx    Looks up the MX records for a particular host   help, h Shows a list of commands or help for one commandGLOBAL OPTIONS:  --help, -h   show help  --version, -v print the version보시다시피, 모든 명령이 출력의 명령 섹션에 성공적으로 나열되었습니다.   결론 : 따라서 이 포스트에서는 Github의 urface/cli 패키지를 사용하여 매우 간단하면서도 효과적인 CLI를 성공적으로 구축했습니다. CLI는 최소한의 번거 로움없이 모든 주요 운영 체제에 대해 크로스 컴파일 될 수 있으며 프로덕션 급 커맨드라인 인터페이스에서 기대할 수 있는 모든 기능을 갖추고 있습니다. "
    }, {
    "id": 18,
    "url": "http://localhost:4000/Ch04-Creating-A-Simple-Web-Server-With-Golang/",
    "title": "Golang을 사용하여 간단한 웹 서버 만들기",
    "body": "2020/04/08 -  Table Of Contents:           전제 조건          기본 웹 서버 만들기          서버 실행          약간의 복잡성 추가          정적 파일 제공          작동 확인          디렉토리에서 컨텐츠 제공          작동 확인          HTTPS를 통한 콘텐츠 제공          키 생성          결론          추천 자료      웹 서버는 새로운 언어를 배우려고 할 때 항상 시작되고 실행되는 정말 시원하고 비교적 간단한 프로젝트입니다. Go에서 이것은 다르지 않으며 net/http 패키지를 사용하여 웹 서버를 구축하는 것이 일부 기본 사항을 파악하는 훌륭한 방법입니다. 이 포스트에서는 net/http 패키지를 사용하여 매우 간단한 웹 서버를 만드는데 중점을 둘 것입니다. Node의 ExpressJS 또는 Python의 Tornado와 같은 것을 사용해본적이 있다면, 처리 방법과 유사점이 상당히 있다는 것을 발견할 수 있을 것입니다. 먼저 서버에 요청하는 클라이언트에게 정말 간단한 콘텐츠를 제공할 수 있는 간단한 서버를 만드는데 중점을 둘 것입니다. 이 작업을 마치면 정적 파일을 제공하는 방법을 살펴보고 마지막으로 TLS 또는 https를 통한 HTTP를 사용하여 이러한 파일을 제공하는 방법을 간략하게 살펴 보겠습니다.   전제 조건:  개발 머신에 Go 버전 1. 11 이상이 설치되어 있어야합니다.   기본 웹 서버 만들기 : 자, 먼저, URL 경로가 무엇이든 반환하는 매우 간단한 웹 서버를 만들 것입니다. 이것은 우리가 쌓을 수 있는 좋은 기반이 될 것입니다. 12345678910111213141516171819202122package mainimport (   fmt    html    log    net/http )func main() {  http. HandleFunc( / , func(w http. ResponseWriter, r *http. Request) {    fmt. Fprintf(w,  Hello, %q , html. EscapeString(r. URL. Path))  })  http. HandleFunc( /hi , func(w http. ResponseWriter, r *http. Request){    fmt. Fprintf(w,  Hi )  })  log. Fatal(http. ListenAndServe( :8081 , nil))}위의 코드에서 본질적으로 두 개의 다른 핸들러를 정의합니다. 이 핸들러는 첫 번째 매개 변수로 정의한 문자열 패턴과 일치하는 모든 HTTP 요청에 응답합니다. 따라서 본질적으로 홈페이지 또는 http://localhost:8081/ 에 대한 요청이 있을때마다 쿼리가 해당 패턴과 일치할 때 첫 번째 핸들러가 응답하는 것을 보게됩니다.   서버 실행 : 이제 매우 간단한 서버를 만들었으므로 go run server. go를 콘솔에 입력하여 서버를 실행할 수 있습니다. 이 작업이 완료되면 브라우저로 이동하여 http://localhost:8081/world 로 이동하십시오. 이 페이지에서 쿼리 문자열이 진정한 “hello world”방식으로 되돌아 오는 것을 보게 될 것입니다.   약간의 복잡성 추가 : 이제 기본 웹 서버가 설정되었으므로 특정 URL에 도달할 때마다 카운터를 늘리십시오. 웹 서버가 비동기적이라는 사실 때문에 경쟁 조건 버그에 걸리지 않도록 mutex를 사용하여 카운터를 보호해야합니다.  참고 - 뮤텍스가 무엇인지 확실하지 않은 경우 걱정하지 마십시오. 이러한 서버는 경쟁 조건으로부터 보호되지 않는다는 것을 강조하기 위해 사용됩니다. mutex에 대해 더 알고 싶다면 여기에서 다른 튜토리얼을 확인하십시오: Go Mutex Tutorial TBA 123456789101112131415161718192021222324252627282930313233343536package mainimport (   fmt    log    net/http    strconv    sync )var counter intvar mutex = &amp;sync. Mutex{}func echoString(w http. ResponseWriter, r *http. Request) {  fmt. Fprintf(w,  hello )}func incrementCounter(w http. ResponseWriter, r *http. Request) {  mutex. Lock()  counter++  fmt. Fprintf(w, strconv. Itoa(counter))  mutex. Unlock()}func main() {  http. HandleFunc( / , echoString)  http. HandleFunc( /increment , incrementCounter)  http. HandleFunc( /hi , func(w http. ResponseWriter, r *http. Request) {    fmt. Fprintf(w,  Hi )  })  log. Fatal(http. ListenAndServe( :8081 , nil))}이것을 실행 한 다음 http://localhost:8081/increment 로 이동하면 해당 페이지를 요청할 때마다 현재 카운트가 잠기고, 증가한 후 잠금 해제 될 것입니다.   정적 파일 제공 : Go 기반 웹 서버의 비동기 특성을 살펴 보았으므로 이제 정적 파일 제공으로 넘어갈 수 있습니다. 먼저 프로젝트 디렉토리 내에 정적 폴더를 만든 다음 간단한 HTML 파일을 만듭니다. 이 예에서는 다음을 다시 제공합니다. 12345678&lt;html&gt; &lt;head&gt;  &lt;title&gt;Hello World&lt;/title&gt; &lt;/head&gt; &lt;body&gt;  &lt;h2&gt;Hello World!&lt;/h2&gt; &lt;/body&gt;&lt;/html&gt;이것을 얻은 후에는 http. ServeFile 메소드를 사용하도록 웹 서버 코드를 수정할 수 있습니다. 본질적으로 이것은 서버에 대한 요청의 URL을 취하고 index. html 이라고하면 브라우저에서 HTML로 렌더링된 index. html 파일을 반환합니다. edit. html 페이지를 작성하고 http://localhost:8081/edit. html 에 요청을 보내면 해당 edit. html 페이지에 넣기로 선택한 HTML 컨텐츠가 리턴됩니다. 123456789101112131415161718192021package mainimport (   fmt    log    net/http )func main() {  http. HandleFunc( / , func(w http. ResponseWriter, r *http. Request) {    http. ServeFile(w, r, r. URL. Path[1:])  })  http. HandleFunc( /hi , func(w http. ResponseWriter, r *http. Request) {    fmt. Fprintf(w,  Hi )  })  log. Fatal(http. ListenAndServe( :8081 , nil))}  작동 확인 : 다시 서버를 실행하고 http://localhost:8081/index. html 로 이동하면 매우 간단한 index. html 파일이 표시됩니다.   디렉토리에서 컨텐츠 제공 : 위의 방법은 경로를 기반으로 파일을 제공하는데 효과적이지만, 이렇게하면 디렉토리 구조가 다음과 같이됩니다. 1234567- main. go # our webserver- index. html- styles/- - style. css- images/- - image1. png- . . . 이것은 나쁘지는 않지만 Go 웹 서버가 복잡해지면 웹 사이트 콘텐츠를 자체 디렉토리로 옮길 수 있습니다. 프로젝트 내에서 static/ 이라는 디렉토리를 만들어 모든 웹 사이트의 정적 파일을 포함합니다. 123456789# Our Updated project structure- main. go- static/- - index. html- - styles/- - - style. css- - images/- - - image1. png- . . . 이렇게하려면 기존 웹 서버 코드를 다음과 같이 수정해야합니다. 12345678910111213package mainimport (   log    net/http )func main() {  http. Handle( / , http. FileServer(http. Dir( . /static )))  log. Fatal(http. ListenAndServe( :8081 , nil))}보시다시피, 우리는 HandleFunc 메소드를 사용하지 않고 경로를 전달하는 http. Handle()과 새로 작성된 static/ 디렉토리를 가리키는 http. Dir()을 사용하기 시작했습니다.   작동 확인 : 이제 코드를 업데이트 했으므로 go run main. go를 사용하여 코드를 다시 실행해 보겠습니다. 그러면 http://localhost:8081에서 웹 서버가 다시 시작되고 해당 URL로 이동하면 새로 생성된 static 디렉토리에 index. html이 표시됩니다.   HTTPS를 통한 콘텐츠 제공 : 완벽하므로 원하는 정적 파일을 제공할 수 있는 매우 간단한 웹 서버를 만들 수 있었지만 아직 보안에 대해서는 생각하지 않았습니다. 웹 서버를 보호하고 HTTPS를 사용하여 컨텐츠를 제공하는 방법은 무엇입니까? Go를 사용하면 다음과 같이 http. ListenAndServeTLS를 사용하도록 기존 웹 서버를 수정할 수 있습니다. 12345678910111213package mainimport (   log    net/http )func main() {  http. Handle( / , http. FileServer(http. Dir( . /static )))  log. Fatal(http. ListenAndServeTLS( :443 ,  server. crt ,  server. key , nil))} 주의 – 이 예에서는 이미 생성 된 server. crt 및 server. key 인증서 파일을 전달합니다.   키 생성 : 키가 아직 생성되지 않은 경우 openssl을 사용하여 자체 서명된 인증서를 로컬로 생성할 수 있습니다. 123$ openssl genrsa -out server. key 2048$ openssl ecparam -genkey -name secp384r1 -out server. key$ openssl req -new -x509 -sha256 -key server. key -out server. crt -days 3650로컬에서 자체 서명 된 인증서를 생성 한 다음 go run main. go를 입력하여 https 웹 서버를 시작할 수 있습니다. https://localhost:8081로 이동하면 이제 자체 서명된 인증서를 기반으로 연결이 보안되는 것을 볼 수 있습니다.   결론 : 이 API는 우리가 API를 가지고 놀면서 서버를 만드는 일련의 GoLang 튜토리얼 중 하나입니다.   추천 자료 :  JWT를 사용하여 REST API 인증 TBA MySQL 튜토리얼로 가기 TBA"
    }, {
    "id": 19,
    "url": "http://localhost:4000/Ch03-Creating-RESTful-API/",
    "title": "Go로 RESTful API 만들기",
    "body": "2020/04/07 -  Table Of Contents:           전제 조건          목표          비디오 튜토리얼          REST 아키텍처          JSON          마샬링          기본 API 시작하기          우리의 기사 구조          모든 기사 검색          라우터 시작하기          라우터 구축          경로 변수          기사 작성 및 업데이트          새로운 기사 만들기          기사 삭제          기사 엔드 포인트 업데이트          Challenge          결론          더 읽을거리      웹 애플리케이션 form을 작성하는 경우 애플리케이션의 동적 부분을 채우고 데이터베이스 내에서 데이터 업데이트 또는 삭제와 같은 태스크를 수행하기 위해 하나 이상의 REST API와 interfacing하고있을 가능성이 높습니다. 이 포스트에서는 전체 범위의 CRUD 조작을 수행할 수 있는 GET, POST, DELETE 및 PUT 엔드 포인트를 표시하는 본격적인 REST API를 빌드합니다. 이 개념을 단순하게 유지하고 기본 개념에 집중하기 위해 백엔드 데이터베이스 기술과 상호 작용하여 다루지 않을 기사를 저장하지는 않을 것입니다. 그러나 필요한 CRUD 조작을 수행하기 위해 데이터베이스를 후속 호출하도록 정의할 함수를 쉽게 업데이트할 수 있는 방식으로이 REST API를 작성합니다. Go를 사용하여 데이터베이스와 상호 작용하는 방법에 대한 자세한 내용을 보려면 다음 기사를 확인하십시오.  MySQL 튜토리얼로 가기 TBA ORM 튜토리얼로 이동 TBA 소스 코드-이 기사의 전체 소스 코드는 다음에서 찾을 수 있습니다: TutorialEdge/create-rest-api-in-go-tutorial   전제 조건:  개발 머신에 Go 버전 1. 11 이상이 설치되어 있어야합니다.   목표 : 이 포스팅의 내용을 마치게 되면 Go에서 모든 측면을 처리할 수 있는 고유한 RESTful API를 작성하는 방법을 알게됩니다. 프로젝트 내에서 POST, GET, PUT 및 DELETE HTTP 요청을 처리할 수 있는 REST 엔드 포인트를 작성하는 방법을 알게됩니다.   비디오 튜토리얼 :   REST 아키텍처 : REST는 웹 사이트에서 엔터프라이즈 응용 프로그램에 이르기까지 오늘날 어디에서나 RESTful 아키텍처 스타일은 별도의 소프트웨어 구성 요소간에 통신을 제공하는 강력한 방법입니다. REST API를 구축하면 소비자와 생산자를 쉽게 분리할 수 있으며 일반적으로 디자인에 의해 stateless입니다.  참고 - REST API의 기본 사항에 대해 자세히 알아 보려면 RESTful API 란 무엇입니까?를 확인하십시오.   JSON : 이 튜토리얼에서는 모든 정보를 주고받는 수단으로 JavaScript 객체 표기법을 사용하며 고맙게도 Go는 표준 라이브러리 패키지인 encoding/json을 사용하여 이러한 형식의 인코딩 및 디코딩에 대한 훌륭한 지원을 제공합니다.  참고 - encoding/json 패키지에 대한 자세한 내용은 공식 문서를 참조하십시오: encoding/json   마샬링 : 우리가 쉽게하기 위해 불필요한 공백없이 매우 긴 문자열을 포함하는 바이트 슬라이스를 생성하는 마샬링이라는 것을 사용하여 GO의 데이터 구조를 JSON으로 쉽게 변환할 수 있습니다.   기본 API 시작하기: 시작하려면 HTTP 요청을 처리할 수 있는 매우 간단한 서버를 만들어야 합니다. 이를 위해 main. go라는 새 파일을 만듭니다. 이 main. go 파일 내에서 3 가지 고유한 기능을 정의하려고 합니다. 루트 URL에 대한 모든 요청을 처리하는 homePage 함수, 정의된 함수로 타겟하는 URL 경로와 일치시키는 handleRequests 함수 및 API를 시작하는 mina 함수로 구성되어 있습니다.  main. go 123456789101112131415161718192021package mainimport (   fmt    log    net/http )func homePage(w http. ResponseWriter, r *http. Request){  fmt. Fprintf(w,  Welcome to the HomePage! )  fmt. Println( Endpoint Hit: homePage )}func handleRequests() {  http. HandleFunc( / , homePage)  log. Fatal(http. ListenAndServe( :10000 , nil))}func main() {  handleRequests()}지금 머신에서이를 실행하면 다른 프로세스에서 아직 가져오지 않은 매우 간단한 API가 포트 10000에서 시작되는 것을 볼 수 있습니다. 로컬 브라우저에서 http://localhost:10000/ 로 이동하면 Welcome to the HomePage! 가 인쇄되어 있는 화면을 띄워야 합니다. 이는 REST API를 빌드할 기반을 성공적으로 생성했음을 의미합니다.  참고 - Go 기반 웹 서버를 만드는 방법에 대한 자세한 포스팅을 보려면 여기에서 확인하십시오: Go(Lang)을 사용하여 간단한 웹 서버 만들기 TBA   우리의 기사 구조 : 웹 사이트에서 기사를 CREATE, READ, UPDATE 및 DELETE할 수 있는 REST API를 작성합니다. CRUD API에 대해 이야기할 때 Creating, Reading, Updating 및 Deleting과 같은 모든 작업을 처리할 수 있는 API를 말합니다. 시작하기 전에 기사 구조를 정의해야합니다. Go에는 이 시나리오에 딱 맞는 구조체 개념이 있습니다. 제목, 설명(desc) 및 내용을 특징으로 하는 Article 구조체를 만들어 보겠습니다. 12345678910type Article struct {  Title string `json: Title `  Desc string `json: desc `  Content string `json: content `}// let's declare a global Articles array// that we can then populate in our main function// to simulate a databasevar Articles []ArticleStruct에는 사이트의 모든 기사를 나타내는 데 필요한 3가지 properties가 포함되어 있습니다. 이 기능을 사용하려면  encoding/json  패키지를 import 목록으로 가져와야합니다. 이제 main 함수를 업데이트하여 Articles 변수에 나중에 검색하고 수정할 수 있는 더미 데이터가 채워지도록 하겠습니다. 1234567func main() {  Articles = []Article{    Article{Title:  Hello , Desc:  Article Description , Content:  Article Content },    Article{Title:  Hello 2 , Desc:  Article Description , Content:  Article Content },  }  handleRequests()}완벽합니다. 이제 /articles 엔드 포인트 만들기로 넘어가서 여기서 정의한 모든 기사를 반환합니다.   모든 기사 검색 : 포스팅의 이 부분에서는 HTTP GET 요청이 발생하면 사이트의 모든 기사를 리턴하는 새 REST 엔드 포인트를 작성합니다. 먼저 returnAllArticles라는 새 함수를 만들어 시작합니다. 이 함수는 새로 채워진 Article 변수를 JSON 형식으로 인코딩하여 반환하는 간단한 작업을 수행합니다.  main. go 1234func returnAllArticles(w http. ResponseWriter, r *http. Request){  fmt. Println( Endpoint Hit: returnAllArticles )  json. NewEncoder(w). Encode(Articles)}json. NewEncoder(w). Encode(article) 호출은 기사 배열을 JSON 문자열로 인코딩한 다음 응답의 일부로 작성하는 작업을 수행합니다. 이것이 작동하기 전에, http://localhost:10000/articles 에 대한 호출을 새로 정의된 함수에 매핑하는 handleRequests 함수에 새로운 경로를 추가해야 합니다. 1234567func handleRequests() {  http. HandleFunc( / , homePage)  // add our articles route and map it to our   // returnAllArticles function like so  http. HandleFunc( /articles , returnAllArticles)  log. Fatal(http. ListenAndServe( :10000 , nil))}이제 이 작업을 수행한 후 go run main. go를 입력하여 코드를 실행한 다음 브라우저에서 http://localhost:10000/articles 를 열고 다음과 같이 기사 목록을 JSON으로 표시해야 합니다.  http://localhost:10000/articles response 123456789101112[ {  Title:  Hello ,  desc:  Article Description ,  content:  Article Content  }, {  Title:  Hello 2 ,  desc:  Article Description ,  content:  Article Content  }]첫 번째 API 엔드 포인트를 성공적으로 정의했습니다. 이 시리즈의 다음 부분에서는 기존의 net/http 라우터 대신 gorilla/mux 라우터를 사용하도록 REST API를 업데이트합니다. 라우터를 교환하면 나중에 필요한 HTTP 요청에 있을 수 있는 경로 또는 쿼리 매개 변수를 구문 분석하는 등의 작업을보다 쉽게 수행할 수 있습니다.   라우터 시작하기 : 이제 표준 라이브러리는 간단한 REST API를 설치하고 실행하는데 필요한 모든 것을 제공하는데 적합하지만 기본 개념을 갖추었으므로 이제 타사 라우터 패키지를 소개할 때가 되었습니다. 가장 눈에 띄고 많이 사용되는 것은 gorilla/mux router인데, 현재 Github에는 2,281개의 stars를 받았습니다.   라우터 구축 : 기존 main. go 파일을 업데이트하고 이전에 있던 표준 라이브러리 대신 gorilla/mux 기반 HTTP router에서 스왑할 수 있습니다. handleRequests 함수가 새 라우터를 작성하도록 수정하십시오.  main. go 12345678910111213141516171819202122232425262728293031package mainimport (   fmt    log    net/http    encoding/json    github. com/gorilla/mux )… // Existing code from abovefunc handleRequests() {  // creates a new instance of a mux router  myRouter := mux. NewRouter(). StrictSlash(true)  // replace http. HandleFunc with myRouter. HandleFunc  myRouter. HandleFunc( / , homePage)  myRouter. HandleFunc( /all , returnAllArticles)  // finally, instead of passing in nil, we want  // to pass in our newly created router as the second  // argument  log. Fatal(http. ListenAndServe( :10000 , myRouter))}func main() {  fmt. Println( Rest API v2. 0 - Mux Routers )  Articles = []Article{    Article{Title:  Hello , Desc:  Article Description , Content:  Article Content },    Article{Title:  Hello 2 , Desc:  Article Description , Content:  Article Content },  }  handleRequests()}이제 이것을 실행하면 시스템 작동 방식에 실질적인 변화가 없습니다. 여전히 같은 포트에서 시작하고 어떤 엔드 포인트에 도달했는지에 따라 동일한 결과를 리턴합니다. 유일한 차이점은 이제 이 포스팅의 뒷부분에서 경로 및 쿼리 매개 변수 검색과 같은 작업을 쉽게 수행할 수 있는 gorilla/mux router가 있다는 것입니다.  $ go run main. go 1Rest API v2. 0 - Mux Routers  경로 변수 : 지금까지는 홈페이지와 모든 기사를 반환하는 매우 간단한 REST API를 만들었습니다. 그러나 하나의 기사만 보려면 어떻게됩니까? gorilla mux 라우터 덕분에 경로에 변수를 추가한 다음 이러한 변수를 기반으로 어떤 기사를 반환할지 선택할 수 있습니다. /articles 경로 바로 아래 handleRequests() 함수 내에 새 경로를 만듭니다. 1myRouter. HandleFunc( /article/{id} , returnSingleArticle)경로에 {id}를 추가했습니다. 이는 정확한 키를 제공하는 기사만 반환할 때 사용할 수 있는 id 변수를 나타냅니다. 현재 Article 구조체에는 Id 속성이 없습니다. 지금 추가해 봅시다: 123456type Article struct {  Id   string `json: Id `  Title  string `json: Title `  Desc  string `json: desc `  Content string `json: content `}그런 다음 main 함수를 업데이트하여 기사 배열에서 Id 값을 채울 수 있습니다. 1234567func main() {  Articles = []Article{    Article{Id:  1 , Title:  Hello , Desc:  Article Description , Content:  Article Content },    Article{Id:  2 , Title:  Hello 2 , Desc:  Article Description , Content:  Article Content },  }  handleRequests()}이제 returnSingleArticle 함수에서 URL에서 이 `{id} 값을 얻을 수 있으며이 기준과 일치하는 기사를 반환할 수 있습니다. 데이터를 어디에도 저장하지 않았으므로 브라우저로 전달 된 ID만 반환합니다. 123456func returnSingleArticle(w http. ResponseWriter, r *http. Request){  vars := mux. Vars(r)  key := vars[ id ]  fmt. Fprintf(w,  Key:   + key)}이제 이것을 실행한 후 http://localhost:1000/article/1 로 이동하면 브라우저 내에서 Key: 1이 인쇄됩니다. 이 key 값을 사용하여 해당 키와 일치하는 특정 기사를 반환합니다. 12345678910111213func returnSingleArticle(w http. ResponseWriter, r *http. Request) {  vars := mux. Vars(r)  key := vars[ id ]  // Loop over all of our Articles  // if the article. Id equals the key we pass in  // return the article encoded as JSON  for _, article := range Articles {    if article. Id == key {      json. NewEncoder(w). Encode(article)    }  }}go run main. go를 호출하여 브라우저에서 http://localhost:10000/article/1 을 엽니다.  http://localhost:10000/article/1 response 123456{Id:  1 ,Title:  Hello ,desc:  Article Description ,content:  Article Content }이제 키 1과 일치하는 기사가 JSON으로 반환된 것을 볼 수 있습니다.   기사 작성 및 업데이트 : 포스팅의 이 부분에서는 CRUD REST API의 Create, Update 및 DELETE 부분을 빌드합니다. 우리는 이미 단일 기사와 모든 기사를 읽을 수 있는 함수로 R을 다루었습니다.   새로운 기사 만들기 : 다시 한 번,이 새 기사를 작성하는 작업을 수행할 새 함수를 작성해야합니다. main. go 파일 내에 createNewArticle() 함수를 만들어 시작하겠습니다. 123456func createNewArticle(w http. ResponseWriter, r *http. Request) {  // get the body of our POST request  // return the string response containing the request body    reqBody, _ := ioutil. ReadAll(r. Body)  fmt. Fprintf(w,  %+v , string(reqBody))}이 함수를 정의하면 handleRequests 함수 내에 정의된 경로 목록에 경로를 추가할 수 있습니다. 그러나 이번에는 라우트 끝에 . Methods( POST )를 추가하여 들어오는 요청이 HTTP POST 요청인 경우에만 이 함수를 호출하도록 지정합니다. 12345678910func handleRequests() {  myRouter := mux. NewRouter(). StrictSlash(true)  myRouter. HandleFunc( / , homePage)  myRouter. HandleFunc( /articles , returnAllArticles)  // NOTE: Ordering is important here! This has to be defined before  // the other `/article` endpoint.   myRouter. HandleFunc( /article , createNewArticle). Methods( POST )  myRouter. HandleFunc( /article/{id} , returnSingleArticle)  log. Fatal(http. ListenAndServe( :10000 , myRouter))}다시 실행한 후 다음 POST body가 포함된 HTTP POST 요청을 제출하십시오. 123456{   Id :  3 ,    Title :  Newly Created Post ,    desc :  The description for my new post ,    content :  my articles content  }엔드 포인트는 request body에 있던 모든 값을 트리거하고 에코합니다. 새 엔드 포인트가 올바르게 작동하는지 확인했으므로 request body의 JSON을 새 Article 구조체로 마샬링하여 나중에 Article 배열에 추가할 수 있도록 createNewArticle 함수를 업데이트 하겠습니다. 12345678910111213func createNewArticle(w http. ResponseWriter, r *http. Request) {  // get the body of our POST request  // unmarshal this into a new Article struct  // append this to our Articles array.     reqBody, _ := ioutil. ReadAll(r. Body)  var article Article   json. Unmarshal(reqBody, &amp;article)  // update our global Articles array to include  // our new Article  Articles = append(Articles, article)  json. NewEncoder(w). Encode(article)}좋습니다! 지금 실행하여 동일한 POST 요청을 애플리케이션에 전송하면 이전과 동일한 JSON 형식을 다시 에코하지만 Article 배열에 새 기사가 추가됩니다. http://localhost:10000/articles를 눌러 지금 확인하십시오.  http://localhost:10000/articles response 1234567891011121314151617181920[  {     Id :  1 ,     Title :  Hello ,     desc :  Article Description ,     content :  Article Content   },  {     Id :  2 ,     Title :  Hello 2 ,     desc :  Article Description ,     content :  Article Content   },  {     Id :  3 ,     Title :  Newly Created Post ,     desc :  The description for my new post ,     content :  my articles content   }]이제 새 REST API에 Create 함수를 성공적으로 추가했습니다! 이 포스트의 다음 섹션에서는 기사를 삭제할 수있는 새 API 엔드 포인트를 추가하는 방법을 살펴 보겠습니다.   기사 삭제 : REST API에 의해 노출되는 데이터를 삭제해야 할 경우가 있습니다. 이를 위해서는 API 내에서 식별자를 가져와 해당 식별자와 관련된 항목을 삭제하는 DELETE 엔드 포인트를 노출해야합니다. 이 포스팅의 이 섹션에서는 HTTP DELETE 요청을 수신하고 지정된 Id 경로 매개 변수와 일치하는 기사를 삭제하는 다른 엔드 포인트를 작성하려고합니다. main. go 파일에 deleteArticle이라는 새 함수를 추가하십시오. 12345678910111213141516171819func deleteArticle(w http. ResponseWriter, r *http. Request) {  // once again, we will need to parse the path parameters  vars := mux. Vars(r)  // we will need to extract the `id` of the article we  // wish to delete  id := vars[ id ]  // we then need to loop through all our articles  for index, article := range Articles {    // if our id path parameter matches one of our    // articles    if article. Id == id {      // updates our Articles array to remove the       // article      Articles = append(Articles[:index], Articles[index+1:]. . . )    }  }}다시 한 번, 이 새로운 deleteArticle 함수에 매핑되는 handleRequests 함수에 경로를 추가해야합니다. 12345678910func handleRequests() {  myRouter := mux. NewRouter(). StrictSlash(true)  myRouter. HandleFunc( / , homePage)  myRouter. HandleFunc( /articles , returnAllArticles)  myRouter. HandleFunc( /article , createNewArticle). Methods( POST )  // add our new DELETE endpoint here  myRouter. HandleFunc( /article/{id} , deleteArticle). Methods( DELETE )  myRouter. HandleFunc( /article/{id} , returnSingleArticle)  log. Fatal(http. ListenAndServe( :10000 , myRouter))}http://localhost:10000/article/2 에 새로운 HTTP DELETE 요청을 보내보십시오. 그러면 Article 배열 내에서 두 번째 기사가 삭제되고 HTTP GET 요청으로 http://localhost:10000/articles 를 누르면 이제 단일 Article만 포함됩니다.  참고 - 이 단순성을 유지하기 위해 전역 변수를 업데이트하고 있습니다. 그러나 코드에 경쟁 조건이 없는지 확인하지 않습니다. 이 코드를 스레드로부터 안전하게 만들려면 Go Mutexes TBA에 대한 다른 포스팅을 확인하는 것이 좋습니다.   기사 엔드 포인트 업데이트 : 구현해야하는 최종 엔드 포인트는 업데이트 엔드 포인트입니다. 이 엔드 포인트는 HTTP PUT 기반 엔드 포인트가되며, JSON request body뿐만 아니라 HTTP DELETE 엔드 포인트에 대해 수행한 것과 동일한 방식으로 Id 경로 매개 변수를 가져와야합니다. 수신 HTTP PUT request body에있는 이 JSON에는 업데이트하려는 기사의 최신 버전이 포함됩니다.   Challenge: handleRequests 함수에서 updateArticle 함수와 해당 라우트를 작성하십시오. 이것은 PUT 요청과 일치합니다. 이 작업이 완료되면 createNewArticle 함수에서 사용한 것과 동일한 코드를 사용하여 HTTP request body를 파싱하도록 updateArticle 함수를 구현하십시오. 마지막으로 Article 배열에서 기사를 반복하고 기사를 일치시키고 업데이트해야합니다.   결론 : 이 예제는 Go를 사용하여 작성된 매우 간단한 RESTful API를 나타냅니다. 실제 프로젝트에서는 일반적으로 실제 값을 반환할 수 있도록 데이터베이스와 연결합니다.  소스 코드 - 이 포스트의 전체 소스 코드는 여기에서 확인할 수 있습니다: TutorialEdge/create-rest-api-in-go   더 읽을거리: 이 포스트가 마음에 들었다면 다음 포스팅도 참고해보면 좋습니다.  Designing a Production-Ready REST API TBA Go MySQL Tutorial TBA"
    }, {
    "id": 20,
    "url": "http://localhost:4000/Ch02-Consuming-a-RESTful-API/",
    "title": "Go로 RESTful API 사용하기",
    "body": "2020/04/06 -  Table Of Contents:           전제 조건          API 쿼리하기          GET 요청          포켓몬 구조 만들기          JSON unmarshalling하기          우리의 모든 포켓몬 목록          전체 소스 코드          요약       참고 - Go에서 RESTful API를 작성하는 방법에 대한 포스팅을 보려면 여기를 클릭하십시오. 이 포스트에서는 go를 사용하여 이미 실행중인 RESTful API를 사용하는 방법을 보여 드리겠습니다. 현재 수십만 개에 달하는 개방형 REST API가 있으며 소비되기를 기다리고 있으며 보다 의미있는 것으로 바뀝니다. Todd Motto는 Github에서 우리가 사용할 수 있는 모든 공개 API를 나열하는 활발한 레포지토리를 구성했으며, 우리가 체크 아웃하려는 항목으로 쉽게 드릴 다운할 수 있도록 분류했습니다. 여기에서 찾을 수 있습니다. 이 포스팅의 목적상 브라우저에서 작동하는지 쉽게 테스트 할 수 있는 이미 있는 라이브 API를 사용해야한다고 생각합니다. 우리는 Pokemon과 관련된 모든 알려진 정보를 공개하는 API인 매우 인기있는 pokeapi를 사용할 것입니다. 조금 어리석은 것으로 알고 있지만 표준 명명 규칙을 따르고 인증이 필요 없으므로 입력 장벽이없는 본격적인 API입니다.   전제 조건:  개발 머신에 Go 버전 1. 11 이상이 설치되어 있어야합니다.   API 쿼리하기: 시작하기 위해 우리는 원본 시리즈에서 모든 포켓몬을 쿼리할 것입니다. 이를 반환하는 http://pokeapi. co/api/v2/pokedex/kanto/ API 엔드 포인트가 나옵니다. 브라우저에서 이 엔드 포인트로 이동하면 거대한 JSON 문자열이 출력됩니다. 이는 go 프로그램이 이 엔드 포인트에서 GET 요청을 수행할 때 예상되는 응답입니다.  참고 – 브라우저에서 웹 페이지를 열면 해당 페이지에 대한 GET 요청이 수행됩니다.   GET 요청: 브라우저에서 방금 수행한 작업을 모방하려면 다음과 같은 프로그램을 작성해야합니다. 12345678910111213141516171819202122232425package mainimport (   fmt    io/ioutil    log    net/http    os )func main() {  response, err := http. Get( http://pokeapi. co/api/v2/pokedex/kanto/ )  if err != nil {    fmt. Print(err. Error())    os. Exit(1)  }  responseData, err := ioutil. ReadAll(response. Body)  if err != nil {    log. Fatal(err)  }  fmt. Println(string(responseData))}기본 함수 내에서 먼저 http. Get( http://pokeapi. co/api/v2/pokedex/kanto ) 를 사용하여 API 엔드 포인트를 쿼리한 후 이 결과를 response 또는 err에 맵핑 한 후 확인하십시오. err이 nil이 아닌 경우 그렇다면 우리는 종료합니다. 이 아래에서는 응답의 body를 바이트에서 콘솔로 인쇄할 수 있는 의미있는 것으로 변환합니다. 먼저 ioutil. ReadAll(response. Body)를 사용하여 수신 바이트 스트림에서 데이터를 읽은 다음 print문 내에서 string(responseData)를 사용하여이 []byte 응답을 문자열로 변환합니다. 위 프로그램을 실행하면 API 엔드 포인트에서 GET 요청을 성공적으로 수행한 후 콘솔에서 모든 포켓몬을 출력합니다.   포켓몬 구조 만들기: 위 API 엔드 포인트가 제공하는 JSON 응답의 구조를 알면 이제 객체를 매핑할 수 있는 일련의 structs로 매핑할 수 있습니다. 아래는 압축된 JSON 버전입니다. JSON 응답에는 두 개의 key-value 쌍이 있으며, 첫 번째는 원래 Pokemon이 있는 지역의 name입니다. region은 특정 지역 등에 대한 자세한 정보를 얻기 위해 API에 대한 링크를 제공합니다. 우리가 가장 관심있는 것은 우리가 원하는 모든 포켓몬의 배열을 저장하는 pokemon_entries입니다. 123456789101112131415161718192021{  name : kanto ,  region : {   url : http:\/\/pokeapi. co\/api\/v2\/region\/1\/ ,   name : kanto  },  version_groups :[ . . . ] ],  is_main_series :true,  descriptions :[ . . . ],  pokemon_entries :[  {    entry_number : 1,    pokemon_species : {     url : http:\/\/pokeapi. co\/api\/v2\/pokemon-species\/1\/ ,     name : bulbasaur    }  }  . . .  ]}Go에서 우리는 이것을 3 개의 다른 구조체, 즉 Pokemon 배열을 포함하는 Response 구조체와 이러한 개별 포켓몬과 PokemonSpecies 구조체를 포케몬의 이름에 액세스하기 위한 Pokemon 구조체를 포함하는 구조체로 매핑할 수 있습니다. 12345678910111213141516// A Response struct to map the Entire Responsetype Response struct {  Name  string  `json: name `  Pokemon []Pokemon `json: pokemon_entries `}// A Pokemon Struct to map every pokemon to. type Pokemon struct {  EntryNo int      `json: entry_number `  Species PokemonSpecies `json: pokemon_species `}// A struct to map our Pokemon's Species which includes it's nametype PokemonSpecies struct {  Name string `json: name `}  JSON unmarshalling하기: 이러한 구조체를 정의했으므로 반환된 JSON 문자열을 새 변수로 unmarshalling할 수 있습니다. responseData를 인쇄하는 위치에 아래 세 줄을 추가하여 main 함수에서 이 작업을 수행할 수 있습니다. 12345var responseObject Responsejson. Unmarshal(responseData, &amp;responseObject)fmt. Println(responseObject. Name)fmt. Println(len(responseObject. Pokemon))위 코드에서 Response 타입의 새로운 responseObject 변수를 선언합니다. 그런 다음 responseData를 이 객체로 unmarshalling하고 모든 것이 작동하는지 테스트하기 위해 kanto와 같은 responseObject. Name을 인쇄합니다. 그런 다음 Pokemon 배열의 길이를 인쇄하여 예상과 일치하는지 확인하고 151을 인쇄하면 올바르게 수행한 것을 알았으므로 이제 이 포켓몬을 반복할 수 있습니다.   우리의 모든 포켓몬 목록: 모든 포켓몬을 나열하려면 다음과 같이 responseObjects Pokemon 배열의 모든 객체에 대해 반복되는 for 루프를 만들어야 합니다. 123456789var responseObject Responsejson. Unmarshal(responseData, &amp;responseObject)fmt. Println(responseObject. Name)fmt. Println(len(responseObject. Pokemon))for i := 0; i &lt; len(responseObject. Pokemon); i++ { fmt. Println(responseObject. Pokemon[i]. Species. Name)}이것을 실행하면 모든 포켓몬의 이름이 콘솔에 표시됩니다.   전체 소스 코드: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport (   encoding/json    fmt    io/ioutil    log    net/http    os )// A Response struct to map the Entire Responsetype Response struct {  Name  string  `json: name `  Pokemon []Pokemon `json: pokemon_entries `}// A Pokemon Struct to map every pokemon to. type Pokemon struct {  EntryNo int      `json: entry_number `  Species PokemonSpecies `json: pokemon_species `}// A struct to map our Pokemon's Species which includes it's nametype PokemonSpecies struct {  Name string `json: name `}func main() {  response, err := http. Get( http://pokeapi. co/api/v2/pokedex/kanto/ )  if err != nil {    fmt. Print(err. Error())    os. Exit(1)  }  responseData, err := ioutil. ReadAll(response. Body)  if err != nil {    log. Fatal(err)  }  var responseObject Response  json. Unmarshal(responseData, &amp;responseObject)  fmt. Println(responseObject. Name)  fmt. Println(len(responseObject. Pokemon))  for i := 0; i &lt; len(responseObject. Pokemon); i++ {    fmt. Println(responseObject. Pokemon[i]. Species. Name)  }}  요약: 이 포스트에서는 HTTP 엔드포인트에서 GET 요청을 수행하고 응답의 일반 텍스트 응답을 인쇄하는 방법을 살펴 보았습니다. 그런 다음 JSON 응답을 일반 객체처럼 효과적으로 작업할 수 있는 구조체 객체로 정렬 해제하는 방법을 살펴 보았습니다. "
    }, {
    "id": 21,
    "url": "http://localhost:4000/Ch01-An-Intro-to-Go-Dep/",
    "title": "Go Dep 사용하기",
    "body": "2020/04/05 -  Table Of Contents:           왜 dep인가?          설치하기          dep init          새로운 프로젝트 만들기          Gopkg. toml          Gopkg. lock          The vendor/Directory          유용한 명령어          dep ensure          의존성 추가          종속성 업데이트          dep status          결론      이 포스트에서는 Go의 프로젝트 종속성을 관리하기 위해 Go 에서Dep 도구를 사용하는 방법을 살펴 보겠습니다.   왜 dep인가?: dep 툴은 go 프로그래밍 언어를위한 “official experiment” 의존성 관리 툴입니다. 또한 많은 오버 헤드없이 프로젝트에서 유지 관리해야하는 종속성 목록을관리하는데 도움이되며 시스템의 안정성을 보장하기 위해 특정 버전의 종속성에 고정할 수 있습니다. 종속성 관리 도구가 없으면 동일한 컴퓨터에서 여러 개의 다른 Go 프로그램을 개발할 때많은 어려움을 겪을 수 있습니다. 머신에서 6개의 프로젝트가 사용하는 특정 종속성을 업데이트하면 small API 변경으로 인해해당 프로젝트 중 3 개가 중단될 수 있습니다.   설치하기: 다음과 같이 homebrew를 사용하여 dep 도구를 설치할 수 있습니다. 12$ brew install dep$ brew upgrade dep이 두 명령이 실행되면 터미널 내에서 dep CLI를 사용할 수 있어야합니다.   dep init: dep 도구를 시작할 때 일반적으로 가장 먼저 실행해야하는 것은 dep init 명령입니다. 이 명령은 많은 작업을 수행하며 기존 Go 프로젝트와 최신 프로젝트에서 실행할 수 있습니다. dep init를 호출하면 도구가 몇 가지 작업을 수행합니다.  현재 프로젝트의 종속성을 식별합니다 이러한 종속성이 dep 도구를 사용하는지 여부를 검증합니다.  이러한 각 종속성에 대해 가장 호환 가능한 버전을 선택합니다.   새로운 프로젝트 만들기: dep에 의존하는 새로운 프로젝트를 만들 때 몇 가지 옵션이 있습니다. 가장 좋은 첫 번째 옵션은 $GOPATH 내에 프로젝트를 만드는 것입니다. 평소와 같이 해당 디렉토리로 cd 한 다음 dep init를 호출하십시오: 12345$ mkdir -p $GOPATH/src/github. com/my/project$ cd $GOPATH/src/github. com/my/project$ dep init$ lsGopkg. toml Gopkg. lock vendor/  Gopkg. toml: Gopkg. toml 파일은 프로젝트에서 사용하려는 종속성 및 특정 버전의 종속성을 지정하는 위치입니다. NodeJS 백그라운드에서 오는 경우 이것을 package. json으로,Java 백그라운드에서 오는 경우 pom. xml로 생각하십시오.   Gopkg. lock: Gopkg. lock 파일은 일련의 [[project]] stanzas로 표현되는 프로젝트의 종속성 그래프를전이적으로 완성한 스냅 샷입니다. 일반 유저의 관점에서 이것은 모든 의존성과 그 의존성을 수정한 것의 목록입니다.   The vendor/Directory: vendor/directory는 종속성이 저장된 위치입니다. NodeJS 프로젝트의 node_modules/directory와 동일합니다.   유용한 명령어: dep 명령에는 총 5개의 명령이 있습니다:  init - 새로운 Go 프로젝트를 설정합니다.  status - 프로젝트의 종속성 상태를 보고합니다.  ensure - 프로젝트에서 의존성이 안전하게 벤더되도록 보장합니다.  prune - 종속성을 정리합니다. 이 또한 자동으로 수행됩니다.  version - dep 버전 정보를 표시합니다일반적으로 처음 3 개의 명령으로만 작업하므로 이에 대해 자세히 설명하겠습니다.   dep ensure: dep ensure 명령은 dep 종속성 관리 도구를 사용할 때 고려해야 할 가장 중요한 명령입니다.   의존성 추가: 프로젝트에 새로운 종속성을 추가하려면dep ensure -add 명령을 호출하고 프로젝트의 소스를 지정하여 추가할 수 있습니다. 1$ dep ensure -add github. com/foo/bar github. com/another/project . . .   종속성 업데이트: 프로젝트 내의 일부 종속성을 업데이트하려면dep ensure를 호출할 때 ``-update` 플래그를 사용하여 이를 수행할 수 있습니다. 12345678// dry run testing an update$ dep ensure -update -n// non-dry run$ dep ensure -update// updates a specific package$ dep ensure -update github. com/gorilla/mux// updates to a specific version$ dep ensure -update github. com/gorilla/mux@1. 0. 0  dep status: dep status 명령은 프로젝트의 종속성 상태를 보고합니다. 123$ dep status// output. . .   결론: 이번 포스트에서 dep 도구를 시작하는데 필요한 모든 것을 살펴보았습니다. "
    }, {
    "id": 22,
    "url": "http://localhost:4000/Ch18-Go-Linked-Lists/",
    "title": "Go에서 Linked Lists 다루기",
    "body": "2020/04/04 -  Table Of Contents:           container/list 패키지          Linked Lists 구조 정의하기          Go에서의 Linked Lists를 이용한 반복          Linked List 채우기          Linked List에서 요소 제거          결론          더 읽을거리      이 포스트에서는 Go에서 링크된 목록을 작성하고 작업할 수 있는 방법을 살펴 보겠습니다. 연결된 목록은 computer science에서 매우 다양한 데이터 작업으로 다양한 작업에 사용할 수 있습니다. 그들은 또한 프로그래밍 인터뷰 질문에 많이 사용되므로, 새로운 직업에 잘 적응하려면 그들이 어떻게 작동하고 Go에서 하나를 만들 수 있는지에 대해 아는 지식이 중요합니다!   container/list 패키지: 고맙게도 Go에는 편리한 linked list 구조가 이미 구현되어 있으며 container/list 패키지를 (container/list)의 형태로 사용할 수 있습니다. 이 굉장히 편리한 패키지에는 list 구조에 노출된 여러 가지 다른 유용한 방법이 포함되어 있으므로 linked list를 쉽게 쿼리하고 최소한의 번거로움 없이 반복할 수 있습니다. 이 포스트에서는 고유한 linked list를 정의하고 이러한 linked list로 작업할 때 보다 편리하게 사용할 수 있는 몇 가지 방법을 설명합니다.   Linked Lists 구조 정의하기: 먼저 Go에서 linked list를 정의하는 방법을 살펴보겠습니다.  main. go 123456789101112131415package mainimport (   fmt    container/list )func main() {  fmt. Println( Go Linked Lists Tutorial )  mylist := list. New()  mylist. PushBack(1)  mylist. PushFront(2)  // we now have a linked list with '1' at the back of the list  // and '2' at the front of the list. }이 예제에서는 정수의 linked list를 만들지만 Value 유형을 다른 구조체 유형과 같이 원하는 것으로 변경할 수 있습니다.   Go에서의 Linked Lists를 이용한 반복: Go에서 이와 같은 linked list를 반복할 수 있는 몇 가지 방법이 있습니다. 가장 간단한 방법은 linked list에서 첫 번째 노드를 처리한 다음 for 루프를 사용하여 나머지 linked list를 반복하여 다음 노드가 없는지 확인합니다.  main. go 1234567891011121314151617181920package mainimport (   fmt    container/list )func main() {  fmt. Println( Go Linked Lists Tutorial )    mylist := list. New()  mylist. PushBack(1)  mylist. PushFront(2)  for element := mylist. Front(); element != nil; element = element. Next() {  // do something with element. Value  fmt. Println(element. Value)  }}이를 실행하면 linked list의 각 노드 내에 정의된 모든 값이 인쇄됩니다.  $go run main. go 123Go Linked Lists Tutorial21  Linked List 채우기: linked list를 채우는데는 여러 가지 방법이 있습니다. 이전 코드 스니펫에서 이미 PushBack 및 PushFront 메소드를 보았습니다. 이들은 list의 앞이나 뒤에서 linked list에 새로운 요소를 삽입하는 역할을 합니다.  main. go 12345mylist. PushBack(1)mylist. PushFront(1)mylist. InsertAfter  Linked List에서 요소 제거: linked list에서 요소를 삭제하는데 있어 또 다른 방법이 있습니다. 이 메소드는 적절한 이름의 Remove() 메소드입니다!  main. go 12element := mylist. Front()mylist. Remove(element)Remove 함수는 목록 내 요소에 대한 포인터를 가져 와서 linked list 내에서 특정 임계 값을 충족하지 않는 요소를 필터링하려는 편리한 상황에서 사용할 수 있습니다.  main. go 123456789101112131415161718192021222324252627package mainimport (   fmt    container/list )func main() {  mylist := list. New()  mylist. PushBack(1)  mylist. PushFront(2)    for element := mylist. Front(); element != nil; element = element. Next() {    // do something with element. Value    if element. Value != 1 {      mylist. Remove(element)    }  }    for element := mylist. Front(); element != nil; element = element. Next() {    // do something with element. Value    fmt. Println(element. Value)  }}이것을 실행하면 두 번째 for 루프는 1만 출력하고 특정 기준을 충족하는 요소에 대해 linked list를 성공적으로 필터링했습니다!   결론: 굉장합니다. 이 포스트에서는 Go에서 linked list로 작업하는 방법을 살펴 보았습니다. 우리는 linked list를 정의하고 linked list와 상호작용 할 수 있는 다양한 방법을 다루었습니다.   더 읽을거리: 이 튜토리얼을 즐기거나 유용하다고 생각되면 다음과 같은 다른 포스트를 활용할 수도 있습니다.  Go Maps Tutorial TBA"
    }, {
    "id": 23,
    "url": "http://localhost:4000/Ch17-Go-JSON/",
    "title": "Go JSON 튜토리얼",
    "body": "2020/04/03 -  Table Of Contents:           비디오 튜토리얼          마샬링 JSON          간단한 예          고급 예-중첩 구조          들여 쓰기          전체 소스 코드          언마샬링 JSON          비정형 데이터          결론      이 포스트에서는 Go 애플리케이션에서 JSON으로 작업할 수 있는 방법을 포괄적으로 살펴 보겠습니다. JSON(JavaScript Object Notation)은 의심할 여지없이 웹을 통해 데이터를 주고받는데 가장 널리 사용되는 데이터 형식입니다. 모든 주요 언어는 기본적으로 데이터 형식을 지원하며 Go 역시 다르지 않습니다.  소스 코드-이 포스트의 전체 소스 코드는 여기에서 찾을 수 있습니다 : TutorialEdge/go-json-tutorial   비디오 튜토리얼:   마샬링 JSON: Go에서 JSON을 마샬링하는 방법을 살펴보면서 시작하겠습니다. 마샬링을 사용하면 Go 객체를 JSON 문자열로 효과적으로 변환할 수 있습니다.   간단한 예: 이에 대한 간단한 예를 살펴 보겠습니다. Go 코드에 다음과 같이 Book 구조체가 정의되어 있다고 가정 해보십시오. 1234567type Book struct {  Title string `json: title `  Author string `json: author `}// an instance of our Book structbook := Book{Title:  Learning Concurreny in Python , Author:  Elliot Forbes }Book 구조체의 인스턴스를 JSON으로 변환하려면 encoding/json go 패키지를 사용하면됩니다. 123456byteArray, err := json. Marshal(book)if err != nil {  fmt. Println(err)}fmt. Println(string(byteArray))  고급 예 - 중첩 구조: 이제 Marshalling의 기본 사항을 살펴 보았으므로 중첩된 구조체가 포함된 보다 복잡한 예를 살펴 보겠습니다. 12345678910111213type Book struct {  Title string `json: title `  Author Author `json: author `}type Author struct {  Sales int `json: book_sales `  Age int `json: age `  Developer bool `json: is_developer `}author := Author{Sales: 3, Age: 25, Developer: true}book := Book{Title:  Learning Concurrency in Python , Author: author}이번에는 중첩된 구조체를 특징으로하는 보다 복잡한 구조체를 정의했습니다. 구조체의 정의 내에서 구조체의 필드를 정렬된 JSON의 필드에 직접 매핑하는 JSON 태그를 정의했습니다. 123456byteArray, err := json. Marshal(book)if err != nil {  fmt. Println(err)}fmt. Println(string(byteArray))이제 프로그램 내에서 이를 실행하면 다음과 같은 결과가 나타납니다. 12$ go run main. go{ title : Learning Concurrency in Python , author :{ book_sales :3, age :25, is_developer :true}}  들여쓰기: JSON을 더 읽기 쉬운 방식으로 인쇄하려면 일반 json. Marshal() 함수 대신 json. MarshalIndent() 함수를 사용하면 됩니다. 1234567author := Author{Sales: 3, Age: 25, Developer: true}book := Book{Title:  Learning Concurrency in Python , Author: author}byteArray, err := json. MarshalIndent(book,   ,    )if err != nil {  fmt. Println(err)}MarshalIndent에 두 개의 추가 인수를 전달했습니다. 이 접두사 문자열과 들여 쓰기 문자열입니다. 들여 쓰기 문자열의 길이를 변경하여 더 깊은 들여 쓰기를 추가할 수 있습니다. 이제 이것을 실행하면 출력된 JSON 문자열이 훨씬 더 멋지게 보입니다. 12345678{  title :  Learning Concurrency in Python ,  author : {   book_sales : 3,   age : 25,   is_developer : true }}  전체 소스 코드: 이 예제의 전체 소스 코드는 다음과 같습니다. 123456789101112131415161718192021222324252627282930package mainimport (   encoding/json    fmt )type Book struct {  Title string `json: title `  Author Author `json: author `}type Author struct {  Sales   int `json: book_sales `  Age    int `json: age `  Developer bool `json: is_developer `}func main() {  author := Author{Sales: 3, Age: 25, Developer: true}  book := Book{Title:  Learning Concurrency in Python , Author: author}  byteArray, err := json. Marshal(book)  if err != nil {    fmt. Println(err)  }  fmt. Println(string(byteArray))}  언마샬링 JSON: 이제 구조체를 JSON으로 마샬링하는 방법을 다루었으므로 다른 방법으로 시도해 봅시다. 우리는 JSON 문자열을 가져 와서 그 문자열을 구조체로 비정렬화하여 Go의 일반 구조체처럼 작업할 수 있기를 원합니다. 다른 API를 사용하는 Go 서비스를 사용하는 경우 상호 작용하는 이러한 API는 일반적으로 응답을 JSON 문자열로 반환하므로 일반적으로 직접 구현하는 것을 알게 될 것입니다. 이 예에서는 작은 배터리 센서에서 제공되는 JSON 문자열을 가져와서 이 JSON 문자열을 구조체로 비정렬 화하려고 시도합니다. 1{  name :  battery sensor ,  capacity : 40,  time :  2019-01-21T19:07:28Z  }이번 예제에서 가장 먼저 할 일은 JSON 문자열과 동일한 필드를 가진 구조체를 정의하는 것입니다. 12345type SensorReading struct {  Name string `json: name `  Capacity int `json: capacity `  Time string `json: time `}JSON 문자열의 각 key-value 쌍에 대해 SensorReading 구조체에서 해당 key 이름과 일치하는 필드를 정의했습니다. 또한 구조체 내의 각 필드에 json: KEY 와 같은 tags를 추가했습니다. 이 태그는 어떤 JSON 키가 어떤 struct 필드 값과 일치하는지 나타냅니다. 구조체를 정의했으므로 Unmarshal 함수를 사용하여 JSON 문자열을 구조체로 비정렬화하는 작업을 진행할 수 있습니다. 12345jsonString := `{ name :  battery sensor ,  capacity : 40,  time :  2019-01-21T19:07:28Z }`var reading SensorReadingerr := json. Unmarshal([]byte(jsonString), &amp;reading)fmt. Printf( %+v\n , reading)JSON을 포함하는 jsonString을 json. Unmarshal 함수 호출로 전달할 때 바이트 배열로 캐스트했습니다. 또한 &amp;reading을 사용하여 JSON 문자열의 정렬을 해제하려는 구조체에 대한 참조를 전달했습니다. 그런 다음 이를 실행하면 다음 출력이 표시됩니다. 12$ go run main. go{Name:battery sensor Capacity:40 Time:2019-01-21T19:07:28Z}최소한의 번거로움없이 JSON 문자열을 구조체로 마샬링 해제할 수 있었습니다. 이제 Go 프로그램에서와 마찬가지로 채워진 구조체로 작업할 수 있습니다.   비정형 데이터: 때로는 읽고있는 JSON 문자열의 구조에 대한 지식이 없을 수도 있습니다. JSON을 언 마샬링 할 수있는 사전 정의된 구조체를 생성하지 못할 수 있습니다. 이 경우, 비정렬화 할 유형으로map[string]interface{}을 사용하는 다른 방법이 있습니다. 12345str := `{ name :  battery sensor ,  capacity : 40,  time :  2019-01-21T19:07:28Z }`var reading map[string]interface{}err = json. Unmarshal([]byte(str), &amp;reading)fmt. Printf( %+v\n , reading)여기에서는 기존의 SensorReading 코드를 위에서 수정했으며 reading 타입을 이 새로운 map[string]interface{} 유형으로 변경했습니다. 이제 이것을 실행하면 JSON 문자열이 문자열 및 요소의 맵으로 성공적으로 변환되었음을 알 수 있습니다. 12$ go run main. gomap[capacity:40 time:2019-01-21T19:07:28Z name:battery sensor]꼭 짜야 할 경우 유용한 팁이 될 수 있지만 JSON의 구조를 알고 있다면 구조체를 명시적으로 정의하는 것이 좋습니다.   결론: 이번 포스팅에서는 Go 프로그래밍을 이용한 JSON 데이터 파일 또는 구조체로핸들링하는 법에 대해서 알아보았습니다. "
    }, {
    "id": 24,
    "url": "http://localhost:4000/Ch16-Go-Modules/",
    "title": "Go Modules 사용하기",
    "body": "2020/04/02 -  Table Of Contents:           목표          전제 조건          왜 모듈이 필요한가?          문제          간단한 예          프로젝트에 의존성 추가하기          메이저 및 마이너 버전 처리          결론      이 포스트에서는 Go 응용 프로그램에서 Go 모듈을 사용하여 Go 응용 프로그램의 종속성에 대한 작업 방식을 단순화하는 방법을 살펴 보겠습니다. Go Modules를 사용하는 간단한 Go 응용 프로그램을 개발하기 전에 Go Modules의 작동 방식과 문제가 무엇인지 살펴 보겠습니다.   목표: 이 포스팅의 목적:  Go Modules에 대해 잘 알게 됩니다.  Go Modules를 사용하는 Go 패키지를 빌드할 수 있게 됩니다.   전제 조건: 이 포스팅을 따라하기 위해서 다음이 있어야 합니다.  개발 머신에 Go 버전 1. 11 이상이 설치되어 있어야합니다.  GitHub에 계정이 필요합니다.   왜 모듈이 필요한가?: 지난 몇 년 동안 Go 언어의 종속성 관리 공간에서 많은 난기류가 발생했습니다. 우리는 dep, godep, govendor 및 전체 heap과 같은 도구가 이 문제를 한 번에 해결하려고 시도하는 장면에 더 많이 등장하는 것을 보았습니다. Go 모듈은 향후 Go 애플리케이션 내에서 종속성을 처리하기 위한 솔루션의 공식적인 시도로 간주됩니다. 이 작업의 주된 이유는 Go 개발자가 본질적으로 Go 패키지에 시맨틱 버전을 사용할 수 있게 하는 것이 었습니다. 시맨틱 버전 관리 (Semantic Versioning)는 시맨틱 버전 번호를 사용하여 다양한 버전의 애플리케이션과 다양한 패키지 및 라이브러리에 레이블을 지정하는데 널리 사용됩니다. 이 숫자는 v1. 2. 3과 같습니다. 여기서 1은 응용 프로그램의 major 버전이고 2는 minor 버전이고 3은 patch 버전입니다.    Major Versions - 특정 메이저 버전 내의 모든 버전은 다른 마이너 및 패치 버전과 호환됩니다. 이 값을 늘리면 일반적으로 패키지를 사용하는 다른 개발자에게 패키지 작동 방식을 일부 변경했음을 알려줍니다.     Minor Versions - 개발자는 응용 프로그램의 나머지 부분에서 이전 버전과의 호환성을 유지하면서 새로운 기능이나 패키지에 새로운 기능을 추가할 때 패키지 또는 응용 프로그램의 minor 버전을 늘리는 경향이 있습니다.     Patch Versions - 패치 버전은 일반적으로 일반적인 버그 수정에 사용됩니다. 개발자가 응용 프로그램 내에서 약간의 문제나 버그를 발견하면 이전 버전과의 호환성을 다시 확인하면서 문제를 해결한 다음 패치 버전을 하나씩 증가시켜 새로운 버그 수정을 나타냅니다.   참고 - 버전이 지정된 Go 모듈에 대한 원래 제안은 여기에서 확인할 수 있습니다: Proposal: Version Go Modules   문제: 패키지 A와 같은 여러 가지 주요 종속성이있는 Go 서비스를 개발한다고 가정 해보십시오. 이제 서비스 패키지를 작성할 때 A 인터페이스에는 인터페이스가 설정되어 있으며 정해진 방식으로 작동합니다. 그러나 패키지 A의 관리자가 버그를 수정하거나 기능을 확장하기 위해 프로그램을 업데이트하면 어떻게됩니까? 운이 좋으면 변경 사항이 응용 프로그램에 영향을 미치지 않을 수도 있지만 운이 좋지 않을 수 있으며 이러한 변경 사항으로 인해 응용 프로그램이 중단될 수 있습니다. 이곳은 하루를 절약하기 위해 버전 관리가 시작되는 곳입니다. 버전 관리를 사용하여 사용하려는 패키지 또는 라이브러리의 정확한 버전을 선택하고 패키지를 작성할 때마다 항상 지정된 버전을 사용하도록 할 수 있습니다.   간단한 예: 포스팅의 이 부분에서는 Go 모듈을 사용하여 종속성을 처리하는 간단한 Go 패키지를 작성합니다. go-modules-test/라는 응용 프로그램을 실행할 수 있는 새 프로젝트를 만들어 보겠습니다: 12$ mkdir -p go-module-test$ cd go-modules-test다음으로이 모듈 내에서 프로젝트를 초기화하여 모듈을 사용하려고합니다. go mod init 명령을 사용하고 placeholder로 github repo 링크를 지정하여 이를 수행할 수 있습니다. 1$ go mod init github. com/tutorialedge/go-modules-test그러면 Go 응용 프로그램의 모든 종속성이 포함된 go. mod 파일이 생성됩니다. 이 작업을 완료하면 프로젝트 디렉토리 내에 main. go라는 새 파일을 작성하십시오.  go-modules-test/main. go 1234567package mainimport  fmt func main() {  fmt. Println( Hello World )}간단한 Go 애플리케이션을 실행하여 이 시점에서 모든 것이 작동하는지 확인합시다.  $ go run main. go 1Hello World  프로젝트에 의존성 추가하기: 이제 기본 프로젝트를 초기화하고 go 모듈을 사용했으므로 이제 한 걸음 더 나아가 코드베이스에 새로운 종속성을 도입할 수 있는 방법을 살펴보겠습니다. 이 튜토리얼에서는  github. com/elliotforbes/test-package 라는 사용자 정의 Go 패키지를 가져오며, Go 모듈을 통한 관리의 심화 연습을 통해보다 고급의 종속성에 익숙해질 수 있습니다. main. go 파일의 맨 위에서 이 새 패키지를 가져 오십시오. 가져온 후 해당 패키지 내에 선언된 함수 중 일부를 사용하는 방법을 살펴 보겠습니다.  go-modules-test/main. go 123456789101112package mainimport (   fmt   sample  github. com/elliotforbes/test-package )func main() {  fmt. Println( Hello World )  sample. MySampleFunction()}프로그램 맨 위에있는 가져오기 목록에 해당 패키지를 추가 했으므로 이제 아래처럼 일부를 사용해 볼 수 있습니다.  $ go run main. go  123456go: finding github. com/elliotforbes/test-package v2. 0. 0go: downloading github. com/elliotforbes/test-package v2. 0. 0go: extracting github. com/elliotforbes/test-package v2. 0. 0Hello WorldVersion 2. 0 of this FunctionHello World 놀랍게도, Go 모듈을 사용하고 해당 Go 애플리케이션 내에서 사용할 외부 종속성을 가져 오는 정말 간단한 Go 애플리케이션을 정의할 수 있었습니다!   메이저 및 마이너 버전 처리: 응용 프로그램이  github. com/elliotforbes/test-package  패키지를 가져올 때 최신 버전을 가져옵니다. 가져올 버전을 세밀하게 제어하려면 go. mod 파일 내에서 필요한 정확한 버전을 정의할 수 있습니다.  go. mod 12345module github. com/TutorialEdge/go-modules-tutorialgo 1. 12require github. com/elliotforbes/test-package v2. 0. 0패키지의 v2. 0. 0에서 v1. 0. 0으로 버전을 수정한 후 다시 실행하면 다음이 표시됩니다.  $ go run main. go  123456go: finding github. com/elliotforbes/test-package v1. 0. 0go: downloading github. com/elliotforbes/test-package v1. 0. 0go: extracting github. com/elliotforbes/test-package v1. 0. 0Hello WorldVersion 1. 0 of this FunctionHello World 프로덕션 환경에서 사용하려는 패키지의 정확한 버전을 성공적으로 정의할 수 있었습니다. 이를 통해 우리가 릴리스 할 대상에 대해 더 큰 확신을 갖게되고, 최종적으로 애플리케이션을 프로덕션 환경으로 푸시할 때 지식없이 기본 패키지 변경으로 인해 치명적으로 중단되지 않습니다.   결론: 이 튜토리얼을 즐기시고 자신의 Go 애플리케이션에서 모듈을 사용하는 방법에 대한 통찰력을 얻으셨기를 바랍니다. "
    }, {
    "id": 25,
    "url": "http://localhost:4000/Ch15-Go-Tickers-Tutorial/",
    "title": "Go Tickers 사용하기",
    "body": "2020/04/01 -  Table Of Contents:           Tickers vs Timers          간단한 예시          간단한 정렬 예시          백그라운드에서 실행          결론          추가 자료      이 포스트에서는 Go의 티커와 고유한 Go 응용 프로그램 내에서 티커를 효과적으로 사용할 수 있는 방법을 살펴 보겠습니다. 티커는 주어진 시간 간격으로 반복적으로 작업을 수행해야 할 때 매우 유용하며, 애플리케이션의 백그라운드에서 이러한 작업을 실행하기 위해 Go routine과 함께 티커를 사용할 수 있습니다.   Tickers vs Timers: 다이빙을하기 전에 tickers와 timers의 차이점을 아는 것이 좋습니다.  Tickers - 반복 작업에 탁월합니다.  Timers - 일회성 작업에 사용됩니다.   간단한 예시: 5 초마다 간단한 fmt. Println 문을 반복적으로 실행하는 매우 간단한 것으로 시작하겠습니다.  main. go 12345678910111213141516171819package mainimport (	 fmt 	 time )func main() {	fmt. Println( Go Tickers Tutorial )	// this creates a new ticker which will  // `tick` every 1 second.   ticker := time. NewTicker(1 * time. Second)	  // for every `tick` that our `ticker`  // emits, we print `tock`	for _ = range ticker. C {		fmt. Println( tock )	}}이제이 프로그램을 실행하면 프로그램이 ctrl-c로 종료될 때까지 Go 응용 프로그램이 무한정 실행되며 1 초마다 터미널에 tock가 출력됩니다.  go run main. go 1234Go Tickers TutorialTockTock^Csignal: interrupt  백그라운드에서 실행: 따라서 ticker를 사용하여 반복적으로 작업을 수행하는 정말 간단한 Go 응용 프로그램을 구현할 수 있었습니다. 그러나 Go 응용 프로그램의 background에서 이 작업을 수행하려면 어떻게 해야할까요? 우리가 백그라운드에서 실행하고 싶은 작업이 있다면, ticker. C를 반복하는 for 루프를 응용 프로그램이 다른 작업을 실행할 수 있도록 goroutine 내부로 옮길 수 있습니다. 티커를 생성하고 backgroundTask()라는 새로운 함수로 루핑하는 코드를 이동한 다음 main() 함수 내에서 go 키워드를 사용하여 이를 goroutine이라고합니다.  main. go 1234567891011121314151617181920212223242526272829package mainimport (	 fmt 	 time )func backgroundTask() {	ticker := time. NewTicker(1 * time. Second)	for _ = range ticker. C {		fmt. Println( Tock )	}}func main() {	fmt. Println( Go Tickers Tutorial )	go backgroundTask()	  // This print statement will be executed before  // the first `tock` prints in the console	fmt. Println( The rest of my application can continue )	// here we use an empty select{} in order to keep  // our main function alive indefinitely as it would  // complete before our backgroundTask has a chance  // to execute if we didn't. 	select{}}좋습니다, 그래서 우리가 계속해서 이것을 실행하면, 백그라운드 태스크 고 루틴이 시작된 후에 main () 함수가 계속 실행되는 것을 볼 수 있습니다.  go run main. go 123456Go Tickers TutorialThe rest of my application can continueTockTockTock^Csignal: interrupt  결론: 따라서 이 포스트에서는 고유한 Go 응용 프로그램 내에서 티커를 기본 스레드와 백그라운드 작업으로 반복 가능한 작업 이전에 사용하는 방법을 살펴 보았습니다.   추가 자료: 이 함수를 음미하고 고급 컨텍스트에서 ticker를 사용하는 방법을 보려면 실시간 YouTube 통계 모니터링 시스템인 다른 기사를 확인하는 것이 좋습니다. "
    }, {
    "id": 26,
    "url": "http://localhost:4000/Ch14-Go-Sorting-With-the-sort-Package/",
    "title": "정렬 패키지를 사용하기",
    "body": "2020/03/31 -  Table Of Contents:           목표          준비하기          간단한 정렬 예시          사용자 정의 정렬 함수          결론          추가 자료      순서대로 항목을 정렬하는 것은 모든 프로그래머가 의심할 여지없이 경력의 한 시점에서 해야할 일입니다. 선택할 수 있는 접근 방식과 정렬 알고리즘이 다양하지만 일반적으로 이미 구현된 패키지를 사용하여 정렬하는 것이 좋습니다.   목표: 이 포스팅을 이해하면 다음을 수행하는 방법을 알게됩니다.  “sort”패키지를 사용하여 Go 응용 프로그램 내에서 기본 sort 구현 복합 데이터 구조를 정렬할 수 있는 사용자 정의 sort 함수 구현  준비하기: 이 포스팅의 내용을 수행하려면 다음이 필요합니다.  GoLang v1. 11+ 이상 작업할 수 있는 텍스트 편집기  간단한 정렬 예시: 다양한 배열을 정렬할 수 있는 정말 간단한 정렬 응용 프로그램을 살펴 보겠습니다. 새 프로젝트 디렉토리 내에 main. go라는 새 파일을 작성하십시오. 이 안에 int 요소의 배열을 정의할 것 입니다.  main. go 1234567891011package mainimport  fmt func main() {  fmt. Println( Go Sorting Tutorial )    // our unsorted int array  unsorted := []int{1,3,2,6,3,4}	fmt. Println(unsorted)}그리고 이것을 실행하면 다음을 얻을 수 있습니다: 1234$ go run main. goGo Sorting Tutorial[1 3 2 6 3 4]sort 패키지를 사용하여 이를 정렬하는 방법을 살펴 보겠습니다.  main. go 1234567891011121314151617package mainimport (	 fmt 	 sort )func main() {	fmt. Println( Go Sorting Tutorial )		myInts := []int{1,3,2,6,3,4}	fmt. Println(myInts)		// we can use the sort. Ints	sort. Ints(myInts)	fmt. Println(myInts)}  사용자 정의 정렬 함수: 학습서의 이 섹션에서는 사용자 정의 정렬 함수를 사용하여 보다 복잡한 데이터 구조를 정렬하는 방법을 설명합니다. 사용자 정렬 함수를 구현하려면 먼저 정렬하려는 항목의 유형으로 배열을 정의해야합니다. 이 경우 solitary Age field를 특징으로하는 Programmer 유형의 array을 정렬합니다. 따라서 이 예에서 연령별로 정렬할 때 []Programmer 유형을 정의해야합니다. 그런 다음 이 유형을 기반으로하는 세 가지 방법을 만들어야합니다.  Len()-항목 배열의 길이를 반환 Swap()-정렬된 배열에서 두 요소의 위치를 바꾸는 함수 Less()-위치 i의 항목이 위치 j의 항목보다 작은지 여부에 따라 bool 값을 반환하는 함수입니다. 12345678910111213141516171819202122232425262728293031323334353637package mainimport (	 fmt 	 sort )type Programmer struct {	Age int } type byAge []Programmerfunc (p byAge) Len() int {	return len(p)}func (p byAge) Swap(i, j int) {	p[i], p[j] = p[j], p[i]} func (p byAge) Less(i, j int) bool {	return p[i]. Age &lt; p[j]. Age}func main() {  programmers := []Programmer{		Programmer{Age: 30,},		Programmer{Age: 20,},		Programmer{Age: 50,},		Programmer{Age: 1000,},	}	sort. Sort(byAge(programmers))	fmt. Println(programmers)}이것을 실행하면 programmers 배열이 programmer 구조체의 각 Age 필드를 기준으로 정렬됩니다. 12$ go run main. go[{20} {30} {50} {1000}]  결론: 놀랍게도 이 포스트에서는 “sort” 패키지를 사용하여 Go 응용 프로그램에서 정렬을 구현할 수 있었습니다. 또한 애플리케이션에서보다 복잡한 데이터 구조를 정렬할 수 있는 자체 정렬 기능을 구현하는 방법도 살펴 보았습니다.   추가 자료: 이 포스팅이 이해가 되셨다면 다음과 같은 포스팅을 참고할 수도 있습니다.  [Go 루틴과 함께하는 동시성 (TBA)]"
    }, {
    "id": 27,
    "url": "http://localhost:4000/Challenge-01-Getting-Started-with-Go/",
    "title": "Challenge 01 - Getting Started with Go",
    "body": "2020/03/30 - 첫번째 Go 챌린지에 오신 것을 환영합니다! 이 과제는 기본 Go 개념을 공부하기 위해 만들어졌습니다. 이 과제는 언어에 대한 이해를 높이고 실제와 비슷한 시나리오를 제시하기 위해 고안되었습니다. Challenge Info: 로깅 및 모니터링 시스템에는 현재 서버의 하드웨어 사용률을 추적하여 애플리케이션의 가변적 수요를 처리하기 위해 사전에 확장 및 축소할 수 있는 거대한 시장이 있습니다. 이 과제에서는 개발 시스템의 현재 활용도를 쿼리하는 매우 간단한 명령 줄 응용 프로그램을 작성해야합니다. 목표 : Go를 사용하여 시스템 사용률을 쿼리하는 명령 줄 응용 프로그램을 만듭니다. 응용 프로그램을 실행할 때 CPU 사용률, RAM 사용률 및 백업 저장소 사용률과 같은 시스템 사용률을 테이블 형식으로 반환해야합니다. 이 코드는 단일 main. go 파일에 포함됩니다. Acceptance Criteria: 이 과제를 성공적으로 완료하려면 다음을 성공적으로 수행해야합니다.  머신의 CPU 사용률 수집 컴퓨터의 RAM 사용률 수집 머신의 백업 스토리지 활용도 수집 go run main. go가 실행될 때 콘솔에 결과를 알기 쉽게 표시하십시오. 주요 컨셉: 이 도전을 완수함으로써:  간단한 Go 애플리케이션을 작성하고 이 애플리케이션을 컴파일하고 실행하는 방법을 배우게 됩니다.  os 패키지에 대한 기본 지식과 표준 라이브러리에서 Go 애플리케이션으로 패키지를 가져 오는 방법에 대해 이해합니다. 도전 과제 완수: 도전 과제를 완료하려면 elliotforbes/go-challenges 저장소를 자신의 GitHub 계정에 포크하십시오. 다음으로, 각 도전 과제에 대해 해당 리포지토리 내에 디렉토리를 만드십시오! 이것은 당신에게 당신의 미래의 Go 프로젝트에 대한 훌륭한 참고 자료를 포함하는 매우 편리한 레포를 줄 것입니다! 유용한 튜토리얼: 다음 포스팅이 이 과제를 완료하는데 도움이 될 것입니다.  Go 시작하기"
    }, {
    "id": 28,
    "url": "http://localhost:4000/Ch13-Go-Pointers-Tutorial/",
    "title": "Go 포인터 튜토리얼",
    "body": "2020/03/29 -  Table Of Contents:           소개          포인터 정의하기          포인터에 값 할당하기          무효성          변수 전달하기          결론          추가 자료      이 포스터에서는 Go의 포인터와 고유한 Go 프로그램 내에서 포인터를 사용하는 방법을 설명합니다. 모범 사례를 다루고 포인터에 대한 가장 일반적인 사용 사례를 다룰 것입니다. 이 튜토리얼을 마치면 포인터와 포인터 사용 방법을 제대로 이해하게 될 것입니다.   소개: Go에서 함수를 호출하고 해당 함수에 여러 인수를 전달하면 언어는 인수의 사본을 작성하여 해당 함수 내에서 사용합니다. 예를 들면 다음과 같습니다.  main. go 1234567891011121314package mainimport  fmt func myTestFunc(a int) {  a += 3  fmt. Println(a)}func main() {  a := 2  myTestFunc(a)  fmt. Println(a) // prints out 2}위의 코드에서 myTestFunc는 정수 변수를 받아서 함수 본문의 컨텍스트 내에서 사용하기 위해 사본을 만듭니다. myTestFunc 내에서 변경한 내용은 myTestFunc 함수 본문 내에서만 유지됩니다. 이제 myTestFunc를 호출하고 원래 변수를 업데이트하고 3을 추가해 볼까요ㅡ? 이 특별한 경우에, 우리는 함수 서명을 참조가 아닌 포인터를 갖도록 변경할 수 있습니다. 이는 myTestFunc 함수 내에서 변경한 내용이 사본이 아니라 원래 변수에 대해 수행됨을 의미합니다!  main. go 1234567891011121314package mainimport  fmt func myTestFunc(a *int) {  *a += 3  fmt. Println(*a)}func main() {  a := 2  myTestFunc(&amp;a)  fmt. Println(a) // prints out 5}위 코드를 실행하면 myTestFunc가 a의 원래 값을 올바르게 업데이트하고 3을 추가한 것을 볼 수 있습니다:  $ go run main. go 1255  포인터 정의하기: 이제 물러서서 포인터 작업의 기본 사항을 살펴 보겠습니다. Go 코드 내에서 포인터를 정의하는 방법을 살펴 보겠습니다. 포인터를 정의하기 위해 변수를 선언하는 지점에서 * 기호를 사용할 수 있으며 변수를 pointer 변수로 바꿉니다.  main. go 12345678910package mainimport  fmt func main() {  var age *int  fmt. Println(age)  fmt. Println(&amp;age)}위의 코드를 실행하면 다음과 같은 결과를 얻을 수 있습니다.  $go run main. go 12&lt;nil&gt;0xc00000e018첫 번째 값은 포인터 변수 age의 값을 나타냅니다. 두 번째는 이 변수의 주소를 나타냅니다.   포인터에 값 할당하기:  질문-age 변수에 값을 할당하려고하면 어떻게됩니까? 알다시피, age 변수는 nil입니다. 26으로 설정하고 어떻게되는지 확인해보겠습니다:  main. go 123456789101112package mainimport  fmt func main() {  var age *int  *age = 26  fmt. Println(age)  fmt. Println(&amp;age)}실제로 컴파일러가 패닉 상태가됩니다.  go run main. go 1234567panic: runtime error: invalid memory address or nil pointer dereference[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x1092f6e]goroutine 1 [running]:main. main()    /Users/elliot/Documents/Projects/TutorialEdge/Projects/Go/go-pointers-tutorial/main. go:8 +0x3eexit status 2그 이유는 int 타입의 값에 맞는 충분한 메모리를 할당하기 위해 내장 함수 new를 사용해야하기 때문입니다. 지금 이 작업을 살펴 보겠습니다.  main. go 123456789101112package mainimport  fmt func main() {  var age *int  age = new(int)  *age = 26  fmt. Println(*age)  fmt. Println(&amp;age)} 중요 사항 - 위 예제에서 main 함수의 첫 번째 줄을 제거하고 age = new(int)를 age := new(int)로 수정하면 좀 더 간결하게 만들 수 있습니다.   무효성:  중요 참고 - Go 코드 내에서 포인터를 사용하면 얻을 수 있는 큰 이점은 포인터가 무효화 (nullable)될 수 있다는 것입니다. pointer 반환 값이 있는 함수가 있으면 그 포인터가 nullable 하다는 사실을 이용할 수 있습니다. 이 첫 번째 함수를 예로 들어 보겠습니다: 12345678func testFunc(id string) (Guitarist, error) {  result, err := getSongs(id)  if err != nil {    return Guitarist{}, err  }  return result, nil}위의 코드에서 우리는 오류를 반환하기 위해 빈 Guitarist{} 구조체를 채워야했습니다. 그러나 포인터 반환 값으로 이 함수를 정의하면 위의 코드를 다음과 같이 단순화 할 수 있습니다. 12345678func testFunc(id string) (*Guitarist, error) {  result, err := getSongs(id)  if err != nil {    return nil, err  }  return result, nil}  변수 전달하기: Go를 가르칠 때 개발자가 포인터 변수를 값 수신기를 사용하는 함수에 전달하는 방법에 대해 종종 우연히 목격합니다. 이에 대한 예를 보겠습니다:  main. go```go package main import “fmt” func YearsUntilRetirement(age int) {  fmt. Println(100 - age)} func main() {	var age *int	age = new(int)	*age = 26 1YearsUntilRetirement(age) } ```우리가 이것을 실행하려고 할 때, 우리는 YearsUntilRetirement 함수에 *int type을 전달할 수 없다고 불평하게 될 것입니다.  go run main. go 12# command-line-arguments. /main. go:13:25: cannot use age (type *int) as type int in argument to YearsUntilRetirement이 포인터의 값을 전달하기 위해 다음과 같이 *age로 함수에 전달하여 역참조 할 수 있습니다.  main. go 123456789101112131415package mainimport  fmt func YearsUntilRetirement(age int) {  fmt. Println(100 - age)}func main() {	var age *int	age = new(int)	*age = 26    YearsUntilRetirement(*age)}이제 Go 프로그램이 정상적으로 실행되는 것을 볼 수 있습니다.  $ go run main. go 174 챌린지 - Go의 포인터에 대한 당신의 이해도를 이 사이트에서 테스트 해보세요.    Go Pointers and linked site   결론: 이 포스트에서는 Go 언어 내에서의 포인터에 대한 기본 사항과 자신의 Go 어플리케이션 내에서 포인터를 사용하는 방법에 대해 설명했습니다.   추가 자료:  Go 인터페이스 (Interfaces) Go 메서드 (Go Methods)"
    }, {
    "id": 29,
    "url": "http://localhost:4000/Ch12-Go-Project-Structure-Best-Practices/",
    "title": "Go 프로젝트 구조 모범 사례",
    "body": "2020/03/28 -  Table Of Contents:           Small Applications - Flat Structure          혜택          이 구조의 예제          Medium/Large 애플리케이션-모듈화          이 구조의 예제          Mature 프로젝트          프로젝트 분할하기          결론          추가 자료      Go 애플리케이션이 따라야하는 구조는 다소 논쟁적인 주제입니다. 어떤 사람들은 모든 사람이 절대적으로 모든 프로젝트에 대해 잘 알려진 golang-standards/project-layout 구조를 따라야한다는 것을 강하게 주장합니다. 그러나 종속성을 처리하기위한 표준으로 Go 모듈이 도입되면서 이 구조는 문제를 제기하기 시작합니다. 기존 구조와 마찬가지로 구조 내의 일부 폴더는 internal 또는 pkg와 같은 폴더에 액세스 할 수 없으며 그대로 유지하려면 다소 해킹된 솔루션을 구현해야 합니다. 이 포스트에서는 Go 응용 프로그램을 새로운 세계 질서로 구성할 때 선택할 수 있는 다양한 옵션을 제시합니다.  참고 – 응용 프로그램을 구성할 때는 “한 번에 한 번”접근하는 방법이 없습니다. 응용 프로그램이 발전함에 따라 프로젝트 구조화 방법도 마찬가지입니다.   Small Applications - Flat Structure: 모든 프로젝트는 소규모로 시작하여 얼마나 성공적인지 또는 개발자가 얼마나 많은 시간을 기꺼이 참여 하느냐에 따라 몸집이 점차 커집니다. 1234567application/ - main. go - main_test. go - utils. go - utils_test. go - . . . 이러한 상황에서는 위에서 설명한 것과 같은 플랫 폴더 구조로 시작하는 것이 좋습니다. 개발자는 프로젝트 구조를 단순하게 유지함으로써 복잡한 구조의 인지적인 오버 헤드없이 가능한한 빨리 원하는 대상에게 최대한의 가치를 제공하는데 집중할 수 있습니다. 나는 종종 개발자들이 실제 가치가있는 어떤 것이 전달되기 전에 프로젝트 초기 단계에서 코드베이스를 정리하고 재정렬하는데 더 많은 시간을 소비하는 것을 보았고 궁극적으로 개발자 또는 개발자 팀과 개발자 사이의 피드백 루프 코스트가 커지게됩니다.   혜택: 이 플랫 폴더 구조는 다음과 같은 개발에 이상적입니다.  마이크로 서비스-분산된 방식으로 배포된 작은 응용 프로그램으로 한 가지 작업만 수행할 수 있습니다.  작은 도구 및 라이브러리-몇 가지 작업을 실제로 수행하는데 중점을 둔 명령줄 도구 또는 작은 라이브러리입니다.   이 구조의 예제: 이 구조가 작동하는 위치의 몇 가지 예를 살펴 보겠습니다.    tidwall/gjson-이 프로젝트는 매우 미니멀한 구조로 프로젝트가 어떻게 성공할 수 있는지에 대한 요점을 거의 완벽하게 보여줍니다. 그들은 프로젝트를 사용하는 사람들에게 실질적인 가치를 제공하는데 초점을 두면서 처음부터 모든 것을 놀라울 정도로 평평하고 너무 복잡하지 않게 유지했습니다.     go-yaml/yaml-완전히 평평한 프로젝트 구조를 특징으로하는 또 다른 멋진 프로젝트    Medium/Large 애플리케이션-모듈화: 프로젝트의 규모와 복잡성이 커짐에 따라 코드베이스 모듈화를 고려해야 할 때가 되는 평평한 구조보다 빠르게 성장하기 시작합니다. 웹 사이트를 강화하는 REST API를 예로 들어 보겠습니다. 이 REST API에는 사용자 등록 및 로그인을 처리하는 엔드 포인트와 CRUD와 같은 방식으로 사용자의 컨텐츠를 처리하는 다른 그룹이 있을 수 있습니다. 이제 애플리케이션을 시맨틱 기능 그룹으로 분리하고 이러한 컴포넌트에서 공유되는 모든 핵심 로직을 프로젝트 내의 공유 패키지로 중앙 집중화하는 것을 고려해야합니다. 12345678910rest-api/- main. go- user/- - user. go- - login. go- - registration. go- articles/- - articles. go- utils/- - common_utils. go  이 구조의 예제: 이 구조를 채택한 Go 프로젝트는 다음과 같습니다.  google/go-cloud - 이 구조를 채택한 프로젝트의 훌륭한 예입니다. 이들은 각 IAAS Cloud Providers에 대한 프로젝트를 패키지로 분할했으며 각 패키지에는 해당 특정 Cloud 제공자와 관련된 모든 코드가 포함되어 있습니다.  hashicorp/consul – 이것은 모듈식 접근 방식을 채택하기로 선택한 대규모 프로젝트의 또 다른 훌륭한 예입니다.  ipfs/go-ipfs - IPFS는 Git 및 BitTorrent와 같은 이전 시스템을 기반으로 Go로 작성된 매우 멋진 P2P 파일 시스템입니다. 다시 한 번, 그들은 시스템을 개발할 때 모듈식 접근 방식을 선택했습니다.  gohugoio/hugo - 현재 이 사이트의 백엔드로 사용되는 매우 멋진 프레임 워크입니다!  Mature 프로젝트: 이전 프로젝트 구조를 준수하는 프로젝트는 계속볼 수 있지만 이는 이러한 응용 프로그램이 개발된 시간의 부산물입니다. Hashicorp의 Terraform 또는 Google 자체 Kubernetes와 같은 대규모 응용 프로그램은 $GOPATH가 최고를 다스렸을 때 아주 잘 작동하던 이전 스타일의 구조의 잔재를 특징으로하는 경향이 있습니다. 여기에는 여전히 프로젝트의 내부 작업 중 일부를 캡슐화하는 internal 및 pkg 폴더가 있습니다.  hashicorp/terraform Kubernetes/kubernetes이 구조는 예외적으로 잘 작동하여 개발자가 개발 커뮤니티에 놀라운 가치를 전달할 수 있게 해주었지만 Go Modules가 널리 보급됨에 따라 이러한 응용 프로그램이 보다 전통적인 구조에서 벗어나 새로운 구조로 이전하게 되는 것을 볼 수 있을 것입니다.   프로젝트 분할하기: 특정 시점이 지나면 프로젝트의 특정 부분을 자체 수명주기가 있는 별도의 리포지토리로 완전히 추출하는 것이 좋습니다. 프로젝트 영역 전체의 업데이트 관리와 관련하여 오버헤드 증가와 같은 고유한 단점이 있습니다. 그러나 이는 또한 프로젝트 참여 및 도움을 원하는 신규 이민자를 위해 프로젝트를 더 쉽게 소화할 수 있음을 의미합니다.   결론: 이 포스트가 개발 노력에 도움이 되었고 다음 Go 프로젝트 모델링을 시작할 때 몇 가지 아이디어를 제공했으면 합니다. 이것들은 일상 업무에서 서비스 및 서비스 중개인을 개발하는 개인적인 개발 경험에 근거한 저의 발견입니다. 이러한 구조를 사용할 때 자신의 마일리지가 다를 수 있지만 아래 의견 섹션에서 Go 응용 프로그램을 구성하는 방법에 대한 자신의 생각과 팁을 듣고 싶습니다!   추가 자료: 이 포스팅과 연계하여 다음 포스팅도 살펴봐 주세요.  Go 모듈 튜토리얼 (TBA)"
    }, {
    "id": 30,
    "url": "http://localhost:4000/Ch11-The-Go-init-Function/",
    "title": "Go init 함수",
    "body": "2020/03/27 -  Table Of Contents:           init 함수란?          다중 패키지          초기화 순서          같은 파일 안에서의 다중 Init 함수          결론      Go에서 응용 프로그램을 만들 때 프로그램을 처음 시작할 때 어떤 형태의 상태를 설정할 수 있어야하는 경우가 있습니다. 여기에는 데이터베이스에 대한 연결을 만들거나 로컬로 저장된 configuration 파일에서 configuration을 로드하는 것이 포함될 수 있습니다. Go에서 이 작업을 수행할 때 init() 함수가 작동합니다. 이 포스트에서는 이 init() 함수를 사용하여 다음 Go 기반 프로젝트를 빌드하는데 도움이되는 방법을 살펴 보겠습니다.   init 함수란?: Go에서 init() 함수는 엄청나게 강력하며 다른 언어와 비교하여 Go 프로그램 내에서 사용하기가 훨씬 쉽습니다. 이러한 init() 함수는 package 블록 내에서 사용할 수 있으며 패키지를 가져 오는 횟수에 관계없이 init() 함수는 한 번만 호출됩니다. 이제 한 번만 호출된다는 사실에 주의를 기울여야 합니다. 이를 통해 데이터베이스 연결을 설정하거나 다양한 서비스 레지스트리에 등록하거나 일반적으로 한 번만 수행하려는 다른 많은 작업을 수행할 수 있습니다. 123456789package mainfunc init() { fmt. Println( This will get called on main initialization )}func main() { fmt. Println( My Wonderful Go Program )}이 예제에서 프로그램 내 어디에서나 init() 함수를 명시적으로 호출하지 않았습니다. Go는 암묵적으로 실행을 처리하므로 위의 프로그램은 다음과 같은 출력을 제공해야 합니다. 123$ go run test. goThis will get called on main initializationMy Wonderful Go Program이 작업을 통해 변수 초기화와 같은 멋진 작업을 시작할 수 있습니다. 123456789101112131415package mainimport  fmt var name stringfunc init() {  fmt. Println( This will get called on main initialization )  name =  Elliot }func main() {  fmt. Println( My Wonderful Go Program )  fmt. Printf( Name: %s\n , name)}이 예제에서는 명시적으로 자신의 설정 함수를 호출해야하는 것과 비교하여 init() 함수를 사용하는 것이 왜 바람직한지 알 수 있습니다. 위의 프로그램을 실행할 때 이름 변수가 올바르게 설정되어 있으며 지구상에서 가장 유용한 변수는 아니지만 Go 프로그램 전체에서 계속 사용할 수 있습니다. 1234$ go run test. goThis will get called on main initializationMy Wonderful Go ProgramName: Elliot  다중 패키지: 프로덕션 Go 시스템에서 기대하는 것에 더 가까운 보다 복잡한 시나리오를 살펴 보겠습니다. 애플리케이션, main, broker 및 database 내에 4개의 고유한 Go 패키지가 있다고 상상해보십시오. 이들 각각에서 Kafka 또는 MySQL과 같은 다양한 타사 서비스에 대한 연결 풀 설정 작업을 수행하는 init() 함수를 지정할 수 있습니다. database package에서 함수를 호출할 때마다 init() 함수에서 설정한 연결 풀을 사용합니다.  참고-init() 함수의 실행 순서에 의존할 수 없다는 점은 매우 중요합니다. 대신 순서가 중요하지 않은 방식으로 시스템을 작성하는데 집중하는 것이 좋습니다.   초기화 순서: 더 복잡한 시스템의 경우 특정 패키지를 구성하는 파일이 둘 이상있을 수 있습니다. 이 파일들 각각에는 그들 자신의 init() 함수가 있을 수 있습니다. 그렇다면 Go는 이러한 패키지의 초기화를 어떻게 차례대로합니까? 초기화 순서와 관련하여 몇 가지 사항이 고려됩니다. Go에 있는 것들은 일반적으로 선언 순서대로 초기화되지만 종속된 변수 다음에 명시적으로 초기화됩니다. 즉, 동일한 패키지에 2개의 파일 a. go 및 b. go가 있는 경우 a. go의 초기화가 b. go의 항목에 따라 달라지면 이것들이 먼저 초기화됩니다.  참고-Go의 초기화 순서에 대한 자세한 내용은 공식 문서를 참조하십시오: Package initialization 이 점에서 주목할 점은 이 선언 순서가 다음과 같은 시나리오로 이어질 수 있다는 것입니다. 12345678910111213141516// source: https://stackoverflow. com/questions/24790175/when-is-the-init-function-runvar WhatIsThe = AnswerToLife()func AnswerToLife() int {  return 42}func init() {  WhatIsThe = 0}func main() {  if WhatIsThe == 0 {    fmt. Println( It's all a lie.  )  }}이 시나리오에서는 init() 함수가 호출되기 전에 WhatIsThe 변수가 선언되므로 AnswerToLife()가 init() 함수보다 먼저 실행됩니다.   같은 파일 안에서의 다중 Init 함수: 동일한 Go 파일 내에 여러 개의 init() 함수가 있으면 어떻게 될까요? 처음에는 이것이 가능하다고 생각하지 않았지만 Go는 실제로 하나의 파일 내에 2개의 개별 init() 함수를 지원합니다. 이 init() 함수는 파일 내에서 각각의 선언 순서대로 다시 호출됩니다. 12345678910111213141516171819202122package mainimport  fmt // this variable is initialized first due to// order of declarationvar initCounter intfunc init() {  fmt. Println( Called First in Order of Declaration )  initCounter++}func init() {  fmt. Println( Called second in order of declaration )  initCounter++}func main() {  fmt. Println( Does nothing of any significance )  fmt. Printf( Init Counter: %d\n , initCounter)}위의 프로그램을 실행하면 다음과 같이 출력됩니다. 12345$ go run test. goCalled First in Order of DeclarationCalled second in order of declarationDoes nothing of any significanceInit Counter: 2멋지긴 한데, 왜 우리는 이것을 허용해야 할까요? 보다 복잡한 시스템의 경우 복잡한 초기화 절차를 소화하기 쉬운 여러 init() 함수로 나눌 수 있습니다. 그것은 본질적으로 항상 좋은 단일 init() 함수에 하나의 모 놀리 식 코드 블록을 갖는 것을 피할 수 있게 합니다. 이 스타일의 한 가지 주의해야할 부분은 선언 순서를 보장할 때 주의를 기울여야한다는 것입니다.   결론: 이것으로 init() 함수의 세계에 대한 기본적인 소개를 마치겠습니다. 패키지 초기화 사용법을 익힌 후에는 Go 기반 프로젝트를 구성하는 스킬을 익히는 것이 유용할 수 있습니다. "
    }, {
    "id": 31,
    "url": "http://localhost:4000/Ch10-Parsing-XML-Files-With-Golang/",
    "title": "Go 프로그램으로 XML 파일 파싱하기",
    "body": "2020/03/26 -  Table Of Contents:           XML 파일 예제          파일에서 읽기          Structs 정의하기          Structs로 파싱하기          XML 언마샬링          전체 구현          결론      이 포스팅에서는 파일 시스템에서 XML 파일을 효과적으로 읽고 Go의  encoding/xml  package를 사용하여이 파일을 파싱하는 방법을 살펴 봅니다. 여러 개의 nested된 xml 요소를 순회할 수 있는 방법을 살펴본 후 이를 터미널 창에 간단히 인쇄하는 방법을 알아보겠습니다.   XML 파일 예제: 우선 훑어볼 수 있는 xml 파일이 필요합니다. 12345678910111213141516171819&lt;?xml version= 1. 0  encoding= UTF-8 ?&gt;&lt;users&gt; &lt;user type= admin &gt;  &lt;name&gt;Elliot&lt;/name&gt;  &lt;social&gt;   &lt;facebook&gt;https://facebook. com&lt;/facebook&gt;   &lt;twitter&gt;https://twitter. com&lt;/twitter&gt;   &lt;youtube&gt;https://youtube. com&lt;/youtube&gt;  &lt;/social&gt; &lt;/user&gt; &lt;user type= reader &gt;  &lt;name&gt;Fraser&lt;/name&gt;  &lt;social&gt;   &lt;facebook&gt;https://facebook. com&lt;/facebook&gt;   &lt;twitter&gt;https://twitter. com&lt;/twitter&gt;   &lt;youtube&gt;https://youtube. com&lt;/youtube&gt;  &lt;/social&gt; &lt;/user&gt;&lt;/users&gt;위의 xml에는 사용자 태그, nested 요소에 속성이 설정되어 있으므로 이 예제를 파싱할 수 있으면 확장하여 크기에 관계없이 모든 XML 파일을 파싱할 수 있게 될 것입니다.   파일에서 읽기: 우리가 극복해야 할 첫 번째 장애물은 이 파일을 메모리로 읽는 것입니다. os 와 io/ioutil package의 조합을 사용하여 이를 수행할 수 있습니다. 12345678910111213141516171819202122package mainimport (   fmt    io/ioutil    os )func main() {  // Open our xmlFile  xmlFile, err := os. Open( users. xml )  // if we os. Open returns an error then handle it  if err != nil {    fmt. Println(err)  }  fmt. Println( Successfully Opened users. xml )  // defer the closing of our xmlFile so that we can parse it later on  defer xmlFile. Close()}  Structs 정의하기: xml 파일을 파싱하기 전에 구조체를 정의해야 합니다. 하나는 전체 사용자 목록을 나타내고 하나는 사용자를 나타내고 다른 하나는 사용자의 소셜 링크를 나타냅니다. 123456789101112131415161718192021222324252627282930313233import ( . . .  // remember to add encoding/xml to your list of imports   encoding/xml   . . . )// our struct which contains the complete// array of all Users in the filetype Users struct {  XMLName xml. Name `xml: users `  Users  []User  `xml: user `}// the user struct, this contains our// Type attribute, our user's name and// a social struct which will contain all// our social linkstype User struct {  XMLName xml. Name `xml: user `  Type  string  `xml: type,attr `  Name  string  `xml: name `  Social Social  `xml: social `}// a simple struct which contains all our// social linkstype Social struct {  XMLName xml. Name `xml: social `  Facebook string  `xml: facebook `  Twitter string  `xml: twitter `  Youtube string  `xml: youtube `}  XML 언마샬링: 위에서 우리는 파일을 메모리로 로드하는 방법을 보았습니다. 마샬링하려면 이 파일을 바이트 배열로 변환한 다음 xml. Unmarshal 메서드를 사용하여 Users 배열을 채웁니다. 12345678// read our opened xmlFile as a byte array. byteValue, _ := ioutil. ReadAll(xmlFile)// we initialize our Users arrayvar users Users// we unmarshal our byteArray which contains our// xmlFiles content into 'users' which we defined abovexml. Unmarshal(byteValue, &amp;users)  전체 구현: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package mainimport (   encoding/xml    fmt    io/ioutil    os )// our struct which contains the complete// array of all Users in the filetype Users struct {  XMLName xml. Name `xml: users `  Users  []User  `xml: user `}// the user struct, this contains our// Type attribute, our user's name and// a social struct which will contain all// our social linkstype User struct {  XMLName xml. Name `xml: user `  Type  string  `xml: type,attr `  Name  string  `xml: name `  Social Social  `xml: social `}// a simple struct which contains all our// social linkstype Social struct {  XMLName xml. Name `xml: social `  Facebook string  `xml: facebook `  Twitter string  `xml: twitter `  Youtube string  `xml: youtube `}func main() {  // Open our xmlFile  xmlFile, err := os. Open( users. xml )  // if we os. Open returns an error then handle it  if err != nil {    fmt. Println(err)  }  fmt. Println( Successfully Opened users. xml )  // defer the closing of our xmlFile so that we can parse it later on  defer xmlFile. Close()  // read our opened xmlFile as a byte array.   byteValue, _ := ioutil. ReadAll(xmlFile)  // we initialize our Users array  var users Users  // we unmarshal our byteArray which contains our  // xmlFiles content into 'users' which we defined above  xml. Unmarshal(byteValue, &amp;users)  // we iterate through every user within our users array and  // print out the user Type, their name, and their facebook url  // as just an example  for i := 0; i &lt; len(users. Users); i++ {    fmt. Println( User Type:   + users. Users[i]. Type)    fmt. Println( User Name:   + users. Users[i]. Name)    fmt. Println( Facebook Url:   + users. Users[i]. Social. Facebook)  }}  결론: 이 포스팅이 Golang에서 XML로 작업하는 스킬을 이해하는데 도움이 되었기를 바랍니다. "
    }, {
    "id": 32,
    "url": "http://localhost:4000/Ch09-Parsing-JSON-files-With-Golang/",
    "title": "Go 프로그램으로 JSON 파일 파싱하기",
    "body": "2020/03/25 -  Table Of Contents:           The Encoding/Json Package          JSON 파일 읽기 및 파싱하기          JSON 파일 읽기          Structs로 파싱하기          JSON 비정렬화          비정형 데이터 작업          전체 구현          결론          추가 자료      이 포스트에서는 모두 JSON 파일 또는 JSON HTTP 응답을 읽고 원하는대로 파싱할 수 있는 방법을 살펴 보겠습니다. JSON 또는 Javascript 객체 표기법은 정보를 주고받는 표준 형식입니다. 우리는 XML이나 JSON으로 같은 정보를 표현할 수 있지만 JSON은 훨씬 더 작고 개인적인 경험에서 더 읽기 쉽다는 점에서 이점을 제공합니다. 이제 JSON은 가장 널리 사용되는 데이터 형식이며 대부분의 RESTful API는 인터페이스를 시도할 때 JSON 응답을 제공합니다. 따라서 Go로 작업하고 파싱할 수 있다는 것은 매우 유용합니다!   The Encoding/Json Package: 따라서 시작하기 위해 encoding/json 표준 라이브러리 패키지를 활용하여 시작하고 실행할 것 입니다. 여기에서 공식 문서를 확인하는 것이 좋습니다: Encoding/Json 기본으로 정말 간단한 Go 프로그램부터 시작해 보겠습니다. 다양한 예제를 다루는 방법을 보여주기 위해 이를 구축하겠습니다. main. go라는 새 파일에 다음과 같이 작성하보겠습니다. 123456789package mainimport (   fmt )func main() {  fmt. Println( Hello World )}그리고 간단한 go run main. go 호출로 이것을 실행할 수 있습니다. 간단한 Hello World가 반환됩니다.   JSON 파일 읽기 및 파싱하기 : 간단한 JSON 파일을 읽고 파싱해 봅시다. 이 포스팅의 목적을 위해 파일 내에서 다음 json을 파싱할 것입니다. 이를 복사하여 main. go 파일과 동일한 디렉토리에 있는 users. json 파일 이름으로 저장하세요.  user. json 12345678910111213141516171819202122{  users : [  {    name :  Elliot ,    type :  Reader ,    age : 23,    social : {     facebook :  https://facebook. com ,     twitter :  https://twitter. com    }  },  {    name :  Fraser ,    type :  Author ,    age : 17,    social : {     facebook :  https://facebook. com ,     twitter :  https://twitter. com    }  } ]}이것은 우리의 스킬을 테스트하기에 충분히 복잡해야하며 우리의 스킬을 실제 사례로 쉽게 전환할 수 있어야합니다.   JSON 파일 읽기: 파일 시스템에서 users. json 파일을 열기 위해 os package를 사용할 것입니다. 파일을 열면 함수가 끝날 때까지 파일 닫기를 연기하여 파일 내부의 데이터로 작업할 수 있습니다. 123456789// Open our jsonFilejsonFile, err := os. Open( users. json )// if we os. Open returns an error then handle itif err != nil {  fmt. Println(err)}fmt. Println( Successfully Opened users. json )// defer the closing of our jsonFile so that we can parse it later ondefer jsonFile. Close()  Structs로 파싱하기: users. json 파일에 포함된 JSON을 파싱할 때 몇 가지 옵션이 있습니다. 사전 정의된 구조체 세트를 사용하여 JSON을 unmarshal 하거나 map[string]interface{}를 사용하여 JSON을 unmarshal 하여 JSON을 임의의 데이터 타입에 대해 매핑된 문자열로 파싱할 수 있습니다. 여러분이 원하는 구조를 알고 있다면 다음과 같이 자세한 방법을 따라가며 구조체를 정의하는 것이 좋습니다:  main. go 123456789101112131415161718192021222324252627282930package mainimport (  …  // import our encoding/json package  “encoding/json”  …)// Users struct which contains// an array of userstype Users struct {  Users []User `json: users `}// User struct which contains a name// a type and a list of social linkstype User struct {  Name  string `json: name `  Type  string `json: type `  Age  int  `json: Age `  Social Social `json: social `}// Social struct which contains a// list of linkstype Social struct {  Facebook string `json: facebook `  Twitter string `json: twitter `}이것들을 한 번 정의해 놓으면, JSON을 언제든지 쉽게 unmarshal 할 수 있습니다.   JSON unmarshalling: os. Open 함수를 사용하여 파일을 메모리로 읽은 후에는 ioutil. ReadAll을 사용하여 바이트 배열로 변환해야 합니다. 바이트 배열에 있으면 json. Unmarshal() 메소드에 전달할 수 있습니다. 12345678910111213141516171819// read our opened jsonFile as a byte array. byteValue, _ := ioutil. ReadAll(jsonFile)// we initialize our Users arrayvar users Users// we unmarshal our byteArray which contains our// jsonFile's content into 'users' which we defined abovejson. Unmarshal(byteValue, &amp;users)// we iterate through every user within our users array and// print out the user Type, their name, and their facebook url// as just an examplefor i := 0; i &lt; len(users. Users); i++ {  fmt. Println( User Type:   + users. Users[i]. Type)  fmt. Println( User Age:   + strconv. Itoa(users. Users[i]. Age))  fmt. Println( User Name:   + users. Users[i]. Name)  fmt. Println( Facebook Url:   + users. Users[i]. Social. Facebook)}  비정형 데이터 작업: 때로는 모든 것을 위한 구조체를 만드는 과정을 거치는 것이 다소 시간이 걸리고 해결하려는 문제에 대해 지나치게 장황할 수 있습니다. 이 경우 모든 JSON 데이터를 읽기 위해 표준 interface{}를 사용할 수 있습니다: 1234567891011121314151617181920212223242526272829package mainimport (   encoding/json    fmt    io/ioutil    os )func main() {  // Open our jsonFile  jsonFile, err := os. Open( users. json )  // if we os. Open returns an error then handle it  if err != nil {    fmt. Println(err)  }  fmt. Println( Successfully Opened users. json )  // defer the closing of our jsonFile so that we can parse it later on  defer jsonFile. Close()  byteValue, _ := ioutil. ReadAll(jsonFile)  var result map[string]interface{}  json. Unmarshal([]byte(byteValue), &amp;result)  fmt. Println(result[ users ])}위 코드에서 알 수 있듯이 우리는 users. json을 열고 일반적으로 Python 또는 JavaScript와 같은 다른 프로그래밍 언어에서와 마찬가지로 JSON을 파싱합니다. 이것을 실행하면, result[ users ]를 출력하면 맵이 콘솔에 출력되는 것을 볼 수 있습니다: 123$ go run main. goSuccessfully opened users. json[map[type:Reader age:23 social:map[facebook:https://facebook. com twitter:https://twitter. com] name:Elliot] map[name:Frasertype:Author age:17 social:map[facebook:https://facebook. com twitter:https://twitter. com]]]트리를 더 아래로 이동하려면 구조체 유형을 정의하지 않고도 Go 내에서 map 구조를 일반적으로 탐색할 수 있습니다.  참고-데이터가 유입되는 구조를 알고있는 경우 일반적으로 구조체를 시도하고 정의하는 것이 좋습니다.   전체 구현: 아래는 이 포스팅의 전체 구현입니다.  main. go 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package mainimport (   encoding/json    fmt    io/ioutil    os    strconv )// Users struct which contains// an array of userstype Users struct {  Users []User `json: users `}// User struct which contains a name// a type and a list of social linkstype User struct {  Name  string `json: name `  Type  string `json: type `  Age  int  `json: Age `  Social Social `json: social `}// Social struct which contains a// list of linkstype Social struct {  Facebook string `json: facebook `  Twitter string `json: twitter `}func main() {  // Open our jsonFile  jsonFile, err := os. Open( users. json )  // if we os. Open returns an error then handle it  if err != nil {    fmt. Println(err)  }  fmt. Println( Successfully Opened users. json )  // defer the closing of our jsonFile so that we can parse it later on  defer jsonFile. Close()  // read our opened xmlFile as a byte array.   byteValue, _ := ioutil. ReadAll(jsonFile)  // we initialize our Users array  var users Users  // we unmarshal our byteArray which contains our  // jsonFile's content into 'users' which we defined above  json. Unmarshal(byteValue, &amp;users)  // we iterate through every user within our users array and  // print out the user Type, their name, and their facebook url  // as just an example  for i := 0; i &lt; len(users. Users); i++ {    fmt. Println( User Type:   + users. Users[i]. Type)    fmt. Println( User Age:   + strconv. Itoa(users. Users[i]. Age))    fmt. Println( User Name:   + users. Users[i]. Name)    fmt. Println( Facebook Url:   + users. Users[i]. Social. Facebook)  }}  결론: 이 포스팅이 Golang에서 JSON으로 작업하는 스킬을 이해하는데 도움이 되었기를 바랍니다.   추가 자료: 이 포스팅을 즐겼거나 유용하다고 생각되면 이 사이트에서 다른 포스팅을 볼 수도 있습니다.  Go를 사용하여 RESTful API 작성하기 (TBA) Go를 사용하여 간단한 웹 서버 만들기 (TBA)"
    }, {
    "id": 33,
    "url": "http://localhost:4000/Ch08-Executing-System-Commands-With-Golang/",
    "title": "Go 프로그램으로 시스템 명령을 실행하기",
    "body": "2020/03/24 -  Table Of Contents:           사전 준비          상호 호환성 문제          현재 운영 체제 확인          구현          인수 전달          결론      번 포스팅에서는 표준 라이브러리의 os/exec 패키지를 살펴보고 Go 애플리케이션 내에서 시스템 명령을 성공적으로 실행하기 위해 이 패키지를 어떻게 사용할 수 있는지 살펴 보겠습니다.  참고 – 시스템 명령 실행에 대한 공식 문서 exec package는 os/exec package에 있습니다.   사전 준비:  개발 머신에 Go 버전 1. 11 이상이 설치되어 있어야합니다.   상호 호환성 문제 : 이 명령 중 일부는 운영 체제에서 작동하지 않을 수 있습니다. 여러 플랫폼에서 호환되는 코드를 작성하려는 경우 모든 플랫폼에서 기능한는 명령을 선택하는 것이 좋습니다. 이것이 불가능한 경우, 실행중인 시스템에 따라 다른 시스템 명령을 실행하는 조건부 논리를 프로그램에 추가하는 것이 좋습니다.   현재 운영 체제 확인: 코드가 실행중인 운영 체제를 확인하기 위해 런타임 패키지를 사용하고 GOOS 상수를 확인할 수 있습니다. 운영 체제 타겟을 반환합니다. 12345if runtime. GOOS ==  windows  {    fmt. Println( Can't Execute this on a windows machine )  } else {    execute()  } 참고-전체 GOOS 변수 목록은 Sys Package에서 찾을 수 있습니다.   구현:  참고-필자는 Windows 컴퓨터에서 작동하지 않을 수 있는 명령을 사용하여 MacOS에서 이 포스팅을 작성하고 있습니다. os/exec package를 사용하여 ls 및 pwd와 같은 간단한 명령을 실행하는 방법을 살펴보고, 기본 사항을 다룬 후에 고급 예제로 넘어갈 수 있습니다. 먼저 이 예제의 3가지 핵심 패키지인 fmt, os/exec 및 runtime package를 가져와야 합니다. 이 작업을 수행한 후 execute() 함수를 정의하여 실행해 보겠습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344package mainimport (   fmt    os/exec    runtime )func execute() {  // here we perform the pwd command.   // we can store the output of this in our out variable  // and catch any errors in err  out, err := exec. Command( ls ). Output()  // if there is an error with our execution  // handle it here  if err != nil {    fmt. Printf( %s , err)  }  // as the out variable defined above is of type []byte we need to convert  // this to a string or else we will see garbage printed out in our console  // this is how we convert it to a string  fmt. Println( Command Successfully Executed )  output := string(out[:])  fmt. Println(output)  // let's try the pwd command herer  out, err = exec. Command( pwd ). Output()  if err != nil {    fmt. Printf( %s , err)  }  fmt. Println( Command Successfully Executed )  output = string(out[:])  fmt. Println(output)}func main() {  if runtime. GOOS ==  windows  {    fmt. Println( Can't Execute this on a windows machine )  } else {    execute()  }}그런 다음 이를 실행하면 다음과 같이 표시됩니다. 123456$ go run main. goCommand Successfully Executed # ls commandmain. goCommand Successfully Executed # pwd command/Users/elliot/Documents/Projects/elliotforbes/. . . 보시다시피, 두 명령이 모두 성공적으로 실행되었으며 이러한 명령의 출력을 캡처한 후 자체 Go 프로그램의 컨텍스트 내에서 출력할 수 있었습니다.   인수 전달: 굉장히 간단한 명령을 실행할 수 있었지만 이러한 명령에 인수를 전달하는 방법은 무엇입니까? 예를 들어 표준 ls와 달리 ls -ltr을 원한다고 가정해 보십시오. 고맙게도, 이것은 비교적 쉽습니다. 우리는 이러한 인수를 아래와 같이 . Command()에 추가하기만 하면 합니다. 12345678910111213141516171819202122232425package mainimport (   fmt    os/exec    runtime )func execute() {  out, err := exec. Command( ls ,  -ltr ). Output()  if err != nil {    fmt. Printf( %s , err)  }  fmt. Println( Command Successfully Executed )  output := string(out[:])  fmt. Println(output)}func main() {  if runtime. GOOS ==  windows  {    fmt. Println( Can't Execute this on a windows machine )  } else {    execute()  }}이것을 다시 실행하면 출력이 -ltr flag를 성공적으로 선택하는 것을 볼 수 있습니다. 1234$ go run main. goCommand Successfully Executedtotal 8-rw-r--r-- 1 elliot staff 988 6 Dec 17:52 main. go 참고-. Command()는 여러 개의 후행 인수를 사용하는 Variadic Function의 예 이므로 원하는만큼 초기 명령에 여러 개의 인수를 전달할 수 있습니다.   결론: 이 포스팅에서는 Go에서 os/exec package를 활용하여 Go 프로그램 내에서 시스템 명령을 실행하는 방법을 살펴 보았습니다. "
    }, {
    "id": 34,
    "url": "http://localhost:4000/Ch07-Reading-in-Console-Input-in-Golang/",
    "title": "Go 프로그램으로 콘솔 입력 읽기오기",
    "body": "2020/03/23 -  Table Of Contents:           전체 문장 읽기          single UTF-8로 인코딩된 유니코드 문자 읽기          Bufio의 Scanner 사용하기          결론      Go(GoLang) 프로그램으로 콘솔 텍스트 입력을 읽는 방법에 대한 빠르고 간단한 포스팅입니다. 이 포스트에서는 모든 사용자 입력을 읽고 사용자에게 다시 에코하는 매우 간단한 쉘의 기반을 만들 것입니다.   전체 문장 읽기: 매개변수 없이 for 루프와 동등한 Go’s while 루프를 사용하여 프로그램이 종료되지 않고 계속 지속되도록 합니다. 이 예에서는 텍스트를 입력한 다음 Enter를 누를 때마다 \n 특수 문자를 포함하여 모든 문자와 동일하게 텍스트를 할당합니다. 방금 입력한 문자열을 비교하려면 strings. Replace 메소드를 사용하여 이 입력시 뒤따르는 \n 문자를 제거하고 비교를 수행하십시오.  주의 - Windows 시스템에서이 작업을 수행하려면 Windows에서 UNIX 시스템과 다른 줄 끝을 사용하므로 text = strings. Replace (text,  \r\n ,   , -1)을 수행해야 합니다. 12345678910111213141516171819202122232425262728package mainimport (  bufio   fmt   os   strings )func main() { reader := bufio. NewReader(os. Stdin) fmt. Println( Simple Shell ) fmt. Println( --------------------- ) for {  fmt. Print( -&gt;  )  text, _ := reader. ReadString('\n')  // convert CRLF to LF  text = strings. Replace(text,  \n ,   , -1)  if strings. Compare( hi , text) == 0 {   fmt. Println( hello, Yourself )  } }}이 예에서 “hi”라는 단어를 입력 할 때마다 strings. Compare 메소드는 0을 반환하고 hello를 다시 인쇄합니다.   single UTF-8로 인코딩된 유니코드 문자 읽기: 명령 줄에서 하나의 유니 코드 문자를 간단히 읽으려면 다음과 같이 bufio. ReadRune을 사용하는 것이 좋습니다. 123456789101112131415161718reader := bufio. NewReader(os. Stdin)char, _, err := reader. ReadRune()if err != nil { fmt. Println(err)}// print out the unicode value i. e. A -&gt; 65, a -&gt; 97fmt. Println(char)switch char {case 'A': fmt. Println( A Key Pressed ) breakcase 'a': fmt. Println( a Key Pressed ) break}  Bufio의 Scanner 사용하기: 콘솔에서 입력 내용을 읽을 수 있는 세 번째 방법은 새 스캐너를 만들고 os. Stdin을 전달하는 것입니다. 위와 같이 새 reader를 만든 다음 스캐너를 사용하여 콘솔에서 읽을 수 있습니다. 123456func scanner() { scanner := bufio. NewScanner(os. Stdin) for scanner. Scan() {  fmt. Println(scanner. Text()) }}위의 코드는 입력을 위해 스캔을 무한히 요청하고 입력된 내용을 에코합니다.   결론: 보시다시피 여러 가지 방법이 있으며 최상의 솔루션은 특정 요구 사항에 따라 다릅니다. 단일 문자 입력만 필요한 경우 ReadRune()을 사용하거나 완전히 새로운 줄로 구분된 문장을 읽으려면 ReadString을 사용하십시오. "
    }, {
    "id": 35,
    "url": "http://localhost:4000/Ch06-Go-Interfaces-Tutorial/",
    "title": "Go 인터페이스 (Interfaces)",
    "body": "2020/03/22 -  Table Of Contents:           기본 예제          왜 유용한가?          인터페이스 정의하기          값 반환하기          인터페이스 만족하기          결론      이번 포스팅에서는 Go 프로그래밍 언어의 인터페이스를 살펴 보겠습니다. 이 포스팅에서는 다음 주제를 다룰 것입니다.  인터페이스의 기초 자신 만의 인터페이스 정의하기이 포스팅의 끝에는 이 포스팅에서 다룬 일부 주제를 테스트해보고 유효성 검증을 하기 위해 자신의 컴퓨터에서 자유롭게 시도하고 완료할 수 있는 여러 가지 연습 문제들이 있습니다.  Github 소스 코드 - 이 튜토리얼의 전체 소스 코드는 여기에서 찾을 수 있습니다: TutorialEdge/Go-Interfaces-Tutorial   기본 예제: Go를 처음 사용하는 경우 코드 스니펫이나 튜토리얼에서 interface{}가 많이 표시어있는 것을 볼 수 있습니다. Go에서 인터페이스라는 개념이 무엇이고 인터페이스가 무얼 위해서 사용되는지 모르는 경우, 처음에는 이것을 보는 것이 상당히 어려울 수 있습니다. 전형적인 빈 인터페이스를 기대하는 함수 또는 메서드를 보게된다면, 일반적으로 이 함수/메소드로 무엇이든 전달할 수 있습니다. 이에 대한 예를 살펴 보겠습니다. 12345678910111213141516package mainimport (   fmt )func myFunc(a interface{}) {  fmt. Println(a)}func main() {  var my_age int  my_age = 25  myFunc(my_age)}그런 다음 이것을 실행하면 성공적으로 실행되고 정수 값을 인쇄한다는 것을 알 수 있습니다. 12$ go run main. go25  왜 유용한가?: interface{}를 가져가는 함수를 정의함으로써 본질적으로 원하는 것을 전달할 수 있는 유연성을 제공합니다. Go 프로그래머의 말에 따르면 이 함수에는 무언가가 필요하지만 타입에 신경 쓰지 않아도 된다고 합니다.   인터페이스 정의하기: 그렇다면 인터페이스란 무엇일까요? Go 안에서 왜 사용하는걸까요? Go에서 인터페이스를 정의함으로써 기본적으로 어떤 계약을 정의하게 됩니다. 이 인터페이스를 기반으로 하지 않고 타입을 정의해버리면 해당 인터페이스 에서 정의될 수 있는 모든 타입에 대해 각각의 함수 또는 메소드를 구현해야 합니다. 예를 들어, 기타리스트를 위한 인터페이스를 정의하려고 한다고 가정해 봅시다. 다음과 같이 PlayGuitar() 함수를 포함하도록 인터페이스를 정의할 수 있습니다: 12345type Guitarist interface { // PlayGuitar prints out  Playing Guitar  // to the terminal PlayGuitar()}이렇게 Guitarist 인터페이스를 정의하면, 기타리스트 인터페이스를 구성하는 BaseGuitarist 및 AcousticGuitarist 구조체를 정의할 수 있습니다. 1234567891011121314151617181920212223242526272829303132333435package mainimport  fmt type Guitarist interface {  // PlayGuitar prints out  Playing Guitar   // to the terminal  PlayGuitar()}type BaseGuitarist struct {  Name string}type AcousticGuitarist struct {  Name string}func (b BaseGuitarist) PlayGuitar() {  fmt. Printf( %s plays the Bass Guitar\n , b. Name)}func (b AcousticGuitarist) PlayGuitar() {  fmt. Printf( %s plays the Acoustic Guitar\n , b. Name)}func main() {  var player BaseGuitarist  player. Name =  Paul   player. PlayGuitar()  var player2 AcousticGuitarist  player2. Name =  Ringo   player2. PlayGuitar()}원하는 경우 BaseGuitarist 및 AcousticGuitarist 객체를 모두 저장할 수 있는 Guitarist 타입의 배열을 만들 수 있습니다. 123var guitarists []Guitaristguitarists = append(guitarists, player)guitarists = append(guitarists, player2)  값 반환하기: 실제 예제에서 우리는 일반적으로 인터페이스 내에서 반환 값을 특징으로하는 더 복잡한 함수를 갖게됩니다. Go에서 이러한 인터페이스를 다음과 같이 정의할 수 있습니다. 123456type Employee interface {  Name() string  Language() string  Age() int  Random() (string, error)}  인터페이스 만족하기: 회사에 모든 직원들의 배열을 만들고 싶다고 가정해 보겠습니다. 이 배열 내에서 모든 엔지니어가 필요합니다. 이제 이것이 작동하려면 Employee 인터페이스를 만족시키기 위해 엔지니어 타입이 필요합니다. 그렇지 않으면 프로그램을 컴파일 할 수 없습니다. 123456789101112131415161718192021222324package maintype Employee interface {  Language() string  Age() int  Random() (string, error)}type Engineer struct {  Name string}func (e *Engineer) Language() string {  return e. Name +   programs in Go }func main() {  // This will throw an error  var programmers []Employee  elliot := Engineer{Name:  Elliot }  // Engineer does not implement the Employee interface  // you'll need to implement Age() and Random()  programmers = append(programmers, elliot)}  결론: 이번 포스팅에서 인터페이스가 Go안에서 어떻게 작동하는지 알게되었고 Go 기반 프로그램에서 구현할 수 있는 방법 또한 알아보았습니다. "
    }, {
    "id": 36,
    "url": "http://localhost:4000/Ch05-Go-Methods-Tutorial/",
    "title": "Go 메서드 (Go Methods)",
    "body": "2020/03/21 -  Table Of Contents:           간단한 예제          함수 VS 메서드          결론      이 포스팅에서는 우선 메서드가 무엇인지와 Go 프로그래밍 언어의 범위 내에서 그것이어떻게 작동하는지 살펴 보겠습니다. 그런 다음 메서드과 함수의 차이점과 Go 프로그램 내에서 이상적으로 사용해야하는 시점을 설명합니다.   간단한 예제: Go 시스템에서 스스로 어떤 메서드를 어떻게 구현할 수 있는지를 다루면서 시작하겠습니다. 직원 이름을 업데이트하고 그 이름을 인쇄할 수 있는 매우 간단한 직원 관리 시스템을 만들 것입니다. 아주 흥미로운 예제 프로젝트는 아니지만 데모의 목적으로 사용됩니다. 먼저 이름이 하나인 문자열 필드를 특징으로하는 Employee 타입의 구조체를 만듭니다. 다음으로 우리가 만든 직원의 이름을 업데이트하고 인쇄할 수 있는 UpdateName() 및 PrintName() 메서드를 선언합니다.  main. go 123456789101112131415161718192021222324package mainimport (   fmt )type Employee struct {  Name string}func (e *Employee) UpdateName(newName string) {  e. Name = newName}func (e *Employee) PrintName() {  fmt. Println(e. Name)}func main() {  var employee Employee  employee. Name =  Elliot   employee. UpdateName( Forbsey )  employee. PrintName()} 주의 – 메소드를 사용할 때 주의해야 할 것은 함수와 같이 전달된 인수의 사본을 작성한다는 것입니다. 이를 피하기 위해 메소드를 정의할 때 다음과 같이 포인터 리시버(pointer receivers)를 사용할 수 있습니다.  func (pointer *pointer) myMethod() 그렇다면 왜 Go 프로그램 내에서 메소드를 사용해야 할까요?   함수 VS 메소드: Go에 있는 전형적인 함수와 메서드 사이에는 미묘한 차이가 있습니다. 메서드는 일반적으로 주어진 객체, 즉 guitarist. Update(params)에 대해 작동하며, 이 방식으로 코드를 작성하는 경우 UpdateGuitarist(guitarist, params)를 수행하는 것보다 훨씬 더 친숙하고 선호될 것입니다. 123456func UpdateGuitarist(guitarist *Guitarist, params ParamsStruct) { fmt. Println( This is a simple function )}// Calling this functionUpdateGuitarist(guitarist, params)위의 예에서 guitarist와 guitarist를 업데이트하려는 파라미터를 모두 전달해야합니다. 그런데 우리가 메서드로 이와 동일한 함수를 구현한다면, 호출할 때 더 깔끔해 보일 것입니다: 123456func (g *Guitarist) Update(params ParamsStruct) { fmt. Println( This is a simple method )}// this is far nicer in my opinionmyGuitarist. Update(params)  결론: 이 포스팅에서 우리는 메서드가 무엇인지, 그리고 함수와 어떻게 다른지 알아보았습니다. 이 포스팅이 도움이 되었기를 바라며, 추가 도움이나 코멘트가 필요한 경우, 아래 댓글에 작성해주시면 감사하겠습니다. "
    }, {
    "id": 37,
    "url": "http://localhost:4000/Ch04-Go-Functions-Tutorial/",
    "title": "Go 함수 (Go Functions)",
    "body": "2020/03/20 -  Table Of Contents:           함수 선언          간단한 예제          Full Source Code          Multiple Results From a Function          Anonymous Functions          스스로 도전해보기!          결론          더 읽을거리      이번 포스팅에서는 Golang의 함수를 살펴보고자 합니다. 이 포스팅을 다 읽을 무렵, 함수가 무엇인지, 자신의 프로젝트에서 어떻게 사용할 수 있는지에 대해 확실히 이해하게 되길 바랍니다. 이 포스팅에서는 다음 주제를 다룰 것입니다:  함수 선언의 기초 여러 값을 반환하도록 작동시키는 법이 포스팅의 끝에, 우리가 다루고있는 것을 검증하고 Go에서 본인 스스로 함수를 작성하는 재미를 붙일 수 있도록 자신의 컴퓨터에서 수행할 수 있는 과제가 있습니다.  소스 코드-전체 소스 코드는 이 저장소에서 찾을 수 있습니다: TutorialEdge/Go-Functions-Tutorial   함수 선언: 가장 먼저 알아야 할 것은 go 프로그램 내에서 “함수를 어떻게 선언하는가”입니다. 숙련된 프로그래머라면 전혀 새로운 것이 아닐테고 본인이 숙련된 프로그래머가 아니더라도 당황하지 않아도 됩니다. 이 포스팅에서 알아야 할 모든 것을 다룰 것입니다. Go의 모든 기능은 func 키워드로 시작하고 그 뒤에 함수의 이름이 옵니다. 이름 뒤에 대괄호를 열고 parameter-list와 이와 매우 유사한 스타일로 result-list를 정의합니다: 123func name(parameter-list) (result-list) { // the body of our function}parameter-list와 result-list는 원하는 길이만큼 길게 만들 수 있지만 일반적으로 코드 가독성과 같은 사항을 개선하려면 가능한 작게 유지하는 것이 좋습니다.  대문자 법칙! 다른 패키지에서 이 함수에 액세스하려면 함수 이름의 첫 글자를 대문자로 만들어야 합니다!   간단한 예제: 기본 이론을 다루었으므로 이제 간단한 함수를 정의하여 실제로 살펴 보겠습니다. 이 예제에서는 myFunction이라는 함수를 작성하여 2개의 string 매개 변수를 사용하고 결과 string 출력을 리턴할 것입니다. 1234func myfunction(firstName string, lastName string) (string) { fullname := firstName +     + lastName  return fullname}함수 본문의 첫 번째 행에서 firstName 변수에 공백    과 lastName 변수를 이어붙인 fullname이라는 새 변수를 만들었습니다. 이 연결을 마치면 fullname 변수를 반환합니다.   Full Source Code: 그러면 전체 프로그램 코드의 모양새는 다음과 같습니다.  main. go 1234567891011121314151617package mainimport (   fmt )func myfunction(firstName string, lastName string) (string) { fullname := firstName +     + lastName  return fullname}func main() {  fmt. Println( Hello World )  fullName := myfunction( Elliot ,  Forbes )  fmt. Println(fullName)}  Multiple Results From a Function: Go 프로그램에서는 함수 호출에서 두 가지 결과가 반환되는 경우가 종종 있습니다. 이것은 일반적으로 첫 번째 결과의 결과이며 두 번째 결과의 모든 잠재적 오류입니다. 이 방법은 매우 유용할 수 있으며 go 프로그래머가 함수를 호출하는 원래 함수 블록 내에서 오류를 반환하여 수행할 작업을 결정할 수 있습니다:  main. go 12345678910111213141516171819202122package mainimport (   fmt )func myfunction(firstName string, lastName string) (string, error) { return firstName +     + lastName, nil}func main() { fmt. Println( Hello World ) // we can assign the results to multiple variables // by defining their names in a comma separated list // like so:  fullName, err := myfunction( Elliot ,  Forbes ) if err != nil {  fmt. Println( Handle Error Case ) } fmt. Println(fullName)} 직접 해보기-go run main. go를 호출하여 자신의 컴퓨터에서 이 프로그램을 실행하고 결과를 확인해보세요.   Anonymous Functions: 익명 함수는 함수 선언에 이름이 없다는 점을 제외하면 일반 함수와 매우 유사합니다. 이러한 함수는 명명된 함수 내에서 정의할 수 있으며 다음과 같이 그 익명함수를 감싸고 있는 함수 내의 모든 변수에 액세스 할 수 있습니다:  main. go 123456789101112131415161718192021222324252627package mainimport (  fmt )func addOne() func() int { var x int // we define and return an // anonymous function which in turn // returns an integer value return func() int {  // this anonymous function  // has access to the x variable  // defined in the parent function  x++  return x + 1 }}func main() { myFunc := addOne() fmt. Println(myFunc()) // 2 fmt. Println(myFunc()) // 3 fmt. Println(myFunc()) // 4 fmt. Println(myFunc()) // 5}  스스로 도전해보기!: 새로운 개념을 배우는 가장 좋은 방법 중 하나는 직접 시도해 보는 것입니다. 학습을 돕기 위해 Github 리포지토리 내에 이 프로젝트에 대한 테스트가 실패한 지점을 만들었습니다. 이 테스트는 단순히 정의한 함수가 올바른 결과를 생성하고 프로젝트 디렉토리의 루트 내에서 go test . /. . . 를 호출하여 실행할 수 있는지 확인합니다. 다음 명령을 사용하여 Github 저장소를 로컬로 컴퓨터로 끌어 당기고 Challenge-01 분기로 변경하세요. 12$ git clone https://github. com/TutorialEdge/go-functions-tutorial. git$ git checkout challenge-01 Challenge-01-자신 만의 Add 함수 정의하기 이 문제의 목표는 parameter-list에서 2개의 int 매개 변수를 가져오고 두 값의 합과 동일한 단일 int 값을 리턴하는 main. go 파일 내에 Add 함수를 정의하는 것입니다. Add 함수를 성공적으로 구현했으면 테스트를 실행하여 수행한 작업이 올바른지 확인하십시오. 성공적으로 완료되면 모든 테스트가 통과하고 다음과 같은 출력이 표시됩니다. 12$ go test . /. . . ok   github. com/tutorialedge/go-functions-tutorial  0. 005s 완전한 챌린지 코드-이 코드의 완전한 버전은 여기에서 찾을 수 있습니다: Challenge 01-Complete   결론: 이 포스팅에서는 go 프로그래밍 언어의 함수에 대해 꽤 많은 내용을 다루었습니다. 이것이 여러분에게 유용한 자료였길 바랄게요. 추가 코멘트이나 도움이 필요하면 아래 댓글에서 언제든지 알려주세요!   더 읽을거리:  Go Variadic Function Tutorial"
    }, {
    "id": 38,
    "url": "http://localhost:4000/Ch03-Go-Composite-Types-Tutorial/",
    "title": "Go 복합 데이터 타입 (Go Composite Types)",
    "body": "2020/03/19 -  Table Of Contents:           Arrays          Slices          Maps          Structs          Nested Structs          결론      이번 포스팅에서는 Go 프로그래밍 언어로 제공되는 다양한 복합 데이터 타입 (Composite Data Type)을 살펴 보겠습니다. 이 포스팅의 내용이 생소하다면, 기본 데이터 타입에 대한 다른 포스팅을 확인하고 오시면 도움이 될 것입니다. 복합 데이터 타입에 대해서 잘 이해하려면 이러한 기본 데이터 타입에 대해 알아야합니다.   Arrays: 첫 번째 복합 데이터 형식인 arrays를 어떻게 선언하고 사용할 수 있는지 방법을 살펴 보겠습니다. 모든 요일을 배열로 선언하는 것을 시작해 봅시다. 그러기 위해서는 먼저 빈 배열이 있어야 합니다. 12345// declaring an empty array of stringsvar days []string// declaring an array with elementsdays := [. . . ]string{ monday ,  tuesday ,  wednesday ,  thursday ,  friday ,  saturday ,  sunday }배열의 첫 번째 요소 또는 특정 요소를 쿼리하려는 경우 다른 언어와 매우 유사한 방식으로 쿼리할 수 있습니다. 12fmt. Println(days[0]) // prints 'monday'fmt. Println(days[5]) // prints 'saturday'  Slices: slices와 arrays의 차이점은 매우 미묘합니다. Go에서 slice를 사용하면 기본 array 요소의 하위 집합에 액세스할 수 있게 됩니다. slices는 pointer, length, capacity의 세 가지로 이루어져 있습니다. 예제를 가지고 이것을 시각화 해봅시다. 예를 들어, 우리는 한 주의 모든 요일이 있는 array를 가지고 있고, 우리는 이 array에서 주말을 제외한 요일만을 추출하길 원한다면 slice를 사용할 수 있습니다. 1234days := [. . . ]string{ Monday ,  Tuesday ,  Wednesday ,  Thursday ,  Friday ,  Saturday ,  Sunday }weekdays := days[0:5]fmt. Println(weekdays)// This returns: [Monday Tuesday Wednesday Thursday Friday]  Maps: Maps는 Go에서 hash 테이블을 나타내는 것으로, 임의의 데이터 타입을 다른 타입으로 매핑할 수 있는 데이터 구조입니다. 예를 들어 YouTube 채널 이름에서 해당 채널의 구독자 수에 대한 map을 만들어 보겠습니다. 1234567youtubeSubscribers := map[string]int{  TutorialEdge :   2240,  MKBHD :      6580350,  Fun Fun Function : 171220,}fmt. Println(youtubeSubscribers[ MKBHD ]) // prints out 6580350이것은 string 데이터 타입과 int 데이터 타입 간의 mapping을 나타냅니다.   Structs: Go에서 우리는 struct의 개념을 가지고 있습니다. 이 structs를 사용하면 다른 데이터 형식이 aggregate된 데이터 타입을 만들 수 있습니다. 예를 들어, 우리는 응용 프로그램 내에서 어떤 Person에 대한 개념을 다음과 같이 가지고 있다고 가정해봅시다. 그러면 string 타입의 이름 필드와 int 타입의 age 필드를 가질 수 있는 person struct를 만들 수 있습니다: 12345678// our Person structtype Person struct { name string age int}// declaring a new `Person`var myPerson Person이러한 struct를 사용하면 그 안에 있는 값이나 fields를 모두 단일 엔터티라고 취급되어 이를 효과적으로 처리하고 쉽게 수정할 수 있다는 장점이 있습니다. 12345// declaring a new `elliot`elliot := Person{name:  Elliot , age: 24}// trying to roll back time to before I was injury proneelliot. age = 18  Nested Structs: 구조체 안에 중첩 구조체를 만들 수 있기 때문에 구조체는 엄청나게 확장 가능합니다. 예를 들어, 우리 팀에 많은 사람들이 있는 Team 구조체가 있다고 상상해봅시다. 12345678910111213141516171819202122232425262728package mainimport (   fmt )func main() {  type Person struct {    name string    age int  }  // our Team struct  type Team struct {    name  string    players [2]Person  }  // declaring an empty 'Team'  var myTeam Team  fmt. Println(myTeam)  players := [. . . ]Person{Person{name:  Forrest }, Person{name:  Gordon }}  // declaring a team with players  celtic := Team{name:  Celtic FC , players: players} fmt. Println(celtic)}  결론: 이 포스팅이 유용하길 바라면서 자신의 Go 프로그램 내에서 보다 고급 데이터 타입을 사용하는 방법에 대한 통찰력을 얻으셨길 바랍니다. 유용하거나 자세한 정보가 필요하면 아래의 댓글에 알려주세요! "
    }, {
    "id": 39,
    "url": "http://localhost:4000/Ch02-Go-Basic-Types-Tutorial/",
    "title": "Go 기본 타입 (Go Basic Types)",
    "body": "2020/03/18 -  Table Of Contents:           데이터 타입          Integers          표준 int 타입          타입 변환하기          Floating Point Numbers          Converting float to int and back again          Complex Numbers          Booleans          문자열          상수          결론      이번 포스팅에서는 Go 언어에서 사용할 수 있는 모든 기본 데이터 타입을 살펴 보겠습니다. 이 튜토리얼이 끝나면 언어 내에서 사용 가능한 다양한 데이터 타입에 익숙해질 것이며 자신의 Go 프로그램에서 이러한 타입을 사용하는 방법에 대한 이해가 완료될 것입니다. 이런 종류의 튜토리얼은 배우기에는 상당히 건조하고 지루할 수 있으므로 필요한 기본 사항을 다루면서 이것저것 꾸미고 매끄럽게 만들어서 약간의 재미를 주도록 노력했습니다.   데이터 타입: 따라서, 시작하려면 Go 프로그래밍 언어 내에 4 가지 카테고리의 타입이 있다는 것을 알아야 합니다.  Basic Types-이 튜토리얼에서 다룰 내용 Aggregate Types-배열과 구조체 Reference Types-포인터와 슬라이스 Interface Types-표준 인터페이스  Integers: 우리가 다룰 첫 번째 기본 타입은 정수 타입입니다. 프로그램 내에서 부호있는 정수 또는 부호없는 정수를 사용할 수 있으며 필요한 정수의 크기를 지정할 수 있습니다. 요청하는 크기를 지정하고 싶은 이유는 무엇일까요? 프로그램의 메모리 사용률을 최적화하려고 한다고 상상해 보십시오. 특정 숫자가 특정 값을 초과하지 않는 경우 해당 값에 적합한 메모리 크기를 선택하여 할당할 수 있습니다. 타입 끝에 할당할 메모리 크기와 함께 uint 또는 int를 입력하여 새로운 정수 변수를 만들 수 있습니다. 예를 들어, 8 비트의 부호없는 정수를 원한다면 var myint uint8로 선언할 수 있습니다: 1234567891011121314151617181920212223// all numeric types default to 0// unsigned int with 8 bits// Can store: 0 to 255var myint uint8// signed int with 8 bits// Can store: -127 to 127var myint int8// unsigned int with 16 bitsvar myint uint16// signed int with 16 bitsvar myint int16// unsigned int with 32 bitsvar myint uint32// signed int with 32 bitsvar myint int32// unsigned int with 64 bitsvar myint uint64// signed int with 64 bitsvar myint int64처리할 수 있는 것보다 큰 값을 int에 할당하려고하면 다음과 같습니다: 12var myint int8myint = 2500Go 컴파일러는 프로그램을 실행하거나 빌드하지 못하고 2500이 int8을 오버플로우한다는 사실을 출력합니다. 그러나 런타임에 정수를 오버플로우하게 만들면 이상한 결과가 나타날 수 있습니다. 예를 들어,아래의 프로그램을 실행하고 출력을 검사해 보세요: 123456789101112131415package mainimport (   fmt )func main() {  fmt. Println( Hello World )  var myint int8  for i := 0; i &lt; 129; i++ {    myint += 1  }  fmt. Println(myint) // prints out -127}이것은 이 특정 연산의 결과로 부호있는 정수가 오버플로우 되었기 때문입니다. 이것은 여러분의 프로그램 내에서 주의해야 할 부분입니다!   표준 int 타입: 정수 값을 정의할 때, 이 모든 세부 정보가 너무 많으면 대부분의 경우 기본적으로 int로 설정할 수 있습니다. 이 int 데이터 타입은 일반적으로 기본 시스템이 32 비트 시스템인지 64 비트 시스템인지에 따라 크기가 32 비트 또는 64 비트로 결정됩니다. 간단하게 하기 위해 이 데이터 타입을 기본 값으로 사용하는 것이 가장 편하며 이 타입이 가장 널리 사용되는 것을 볼 수 있습니다.   타입 변환하기: 데이터 타입이 다른 여러 변수로 작업할 때 다양한 정수 변수를 int로 캐스팅 할 필요가 없습니다. 이것은 uint8 및 int16과 같은 것에서 표준 32 또는 64 비트의 부호있는 int로 변환을 처리한 당므 거기에서 더하기, 곱하기 및 빼기와 같은 일을 할 수 있습니다. 1234567891011var men uint8men = 5var women int16women = 6var people int// this throws a compile errorpeople = men + women// this handles converting to a standard format// and is legal within your go programspeople = int(men) + int(women)  Floating Point Numbers : 다음으로, 우리는 부동 소수점 숫자 (Floating Point Numbers)를 살펴보겠습니다. 이들은 float32 또는 float64의 두 가지 메모리 사이즈로 제공되며 표준 int64 데이터 타입에 맞지 않는 매우 큰 숫자를 작업할 수 있게 해줍니다. 12var f1 float32var f2 float64이제 float를 선언하고 작업하는 방법을 살펴보겠습니다: 123456var maxFloat32 float32maxFloat32 = 1688777216fmt. Println(maxFloat32 == maxFloat32+10) // you would typically expect this to return false// it returns truefmt. Println(maxFloat32 + 10)   // 1. 6887772e+09fmt. Println(maxFloat32 + 2000000) // 1. 6907772e+09  Converting float to int and back again: 정수를 부동 소수점으로 변환하거나 부동 소수점을 정수로 변환하려면 변수를 원하는 데이터 타입으로 캐스팅하여 이를 달성할 수 있습니다. 1234567// converting from int to floatvar myint intmyfloat := float64(myint)// converting from float to intvar myfloat2 float64myint2 := int(myfloat2)  Complex Numbers: 자, 정수와 부동 소수점을 모두 다루었지만 일반적으로 간과되는 또 다른 숫자 데이터 타입이 있는데, 그것은 바로 복소수 데이터 타입입니다. 부동 소수점 데이터 타입과 매우 유사한 이 두 가지의 메모리 사이즈로 complex64 또는 complex128을 사용할 수 있습니다. 1234567var x complex128 = complex(1, 2) // 1+2ivar y complex128 = complex(3, 4) // 3+4i// multiplication between complex numbersfmt. Println(x*y)         //  (-5+10i) // extract the each property of complex number (real &amp; imaginary)fmt. Println(real(x*y))      //  -5 fmt. Println(imag(x*y))      //  10   Booleans: 이제 모든 기본 숫자 데이터 타입을 다루었으므로 Go에서 사용할 수 있는 다른 기본 데이터 타입으로 넘어가 보겠습니다. 첫 번째는 bool 또는 boolean 데이터 타입입니다. bool은 true 또는 false를 나타냅니다. Go 프로그램에서 이것이 어떻게 사용될 수 있는지 봅겠습니다: 12345var amazing boolamazing = trueif amazing { subscribeToChannel()}멋지고 단순하지만 프로그램 내에서 약간의 boolean을 이용한 논리 연산을 수행하려면 어떻게 해야할까요?음, ||과 &amp;&amp;을 사용해서 할 수 있습니다! 12345678910var isTrue bool = truevar isFalse bool = false// ANDif isTrue &amp;&amp; isFalse { fmt. Println( Both Conditions need to be True )}// OR - not exclusiveif isTrue || isFalse { fmt. Println( Only one condition needs to be True )}  문자열: Go 언어의 문자열은 문자 조각이라고합니다. string을 사용하여 새로운 문자열 변수를 선언할 수 있습니다: 12var myName stringmyName =  Elliot Forbes   상수: 상수는 우리가 이 포스팅에서 다루는 Go 언어의 마지막 기본 데이터 타입입니다. 이를 통해 프로그램 실행 과정에서 변경되지 않는 불변 값을 지정할 수 있습니다. 1const meaningOfLife = 42  결론: 이번 강의에서 많은 내용을 다루었지만 즐겁게 즐기시기 바랍니다. 추가 도움이 필요하거나 더 알고 싶다면 아래의 댓글란에 알려주세요! "
    }, {
    "id": 40,
    "url": "http://localhost:4000/Ch01-Getting-Started-With-Go/",
    "title": "Go로 시작하기",
    "body": "2020/03/17 -  Table Of Contents:           준비하기          시작하기          결      Go는 다양한 응용 프로그램을 구축할 수 있는 매우 놀라운 언어입니다. command-line 인터페이스에서 분산형 마이크로시스템 및 클라우드 플랫폼에 이르기까지 이 언어가 가지는 단순성과 동시성을 통해 많은 개발팀에서 강력하게 선택하게 되는 언어입니다. 이번 포스팅을 통해서 언어를 익히고 실행하여 더욱 뛰어난 응용 프로그램을 구축하고 기술을 발전시키는데 도움이 되길 바랍니다. 먼저 정말 간단한 Hello World 스타일 응용 프로그램을 시작하고 실행하는데 중점을 두겠습니다. 모든 것을 순조롭게 마친다면 function, method, 그리고 concurrency 및 reflection과 같은 언어의 보다 복잡한 측면을 배우는 과정을 시작할 수 있는 준비가 될 것 입니다.   준비하기: 이 포스트에 있는 내용을 수행하려면 Go가 필요합니다.  자신의 컴퓨터에 Go가 설치되어 있어야 합니다. 공식 다운로드 페이지를 통해 설치할 수 있습니다: Go 공식 다운로드 페이지  시작하기: Go 언어와 관련된 모든 것을 설치하고 매우 간단한 프로그램을 작성해 봅시다. 먼저 현재 자신의 컴퓨터 OS에 따라 사용 가능한 다양한 버전의 Go를 설치할 수 있는 공식 시작하기 페이지로 이동해 봅시다. 현재 시점에서 최신 버전을 설치해 봅시다. 이 포스트를 작성할 당시의 버전은 다음과 같습니다. go 1. 14 설치하고 나면 공식 Go 바이너리가 컴퓨터의 PATH에 추가됩니다. 이 작업을 수행하면 여러분의 터미널에서 go version을 실행할 수 있게 됩니다: 12$ go versiongo version go1. 14 darwin/amd64이것이 제대로 작동하면 우리는 이제 Go 프로그램 작성을 시작할 수 있습니다. 선택한 코드 편집기를 열고 Hello World 프로젝트가 만들어질 새 디렉토리를 만들어 봅시다. 이 디렉토리 내에서 main. go 라는 새 파일을 만들어 봅시다. 우리는 이 파일에 비교적 간단한 Go 프로그램을 만들어보겠습니다. 이 디렉토리 위치에서 터미널을 열고 다음 명령을 실행하려고 합니다. 12$ GOMODULES11=ON $ go mode init github. com/hello/world이를 통해 프로젝트를 초기화하고 향후 Go 코드를 하위 패키지로 분리할 수 있습니다. 또한 최소한의 노력으로 원하는 외부 종속성을 검색할 수 있습니다. 이제 main. go 파일 내에 다음 코드를 추가해봅시다: 12345678910111213141516171819// the first statement of every go source file// must be a package declaration. If we aren't doing anything// fancy, this tends to be package main. package main// We then want to use the fmt package// which features a `print` function - Printlnimport  fmt // We then need to define our main function. // Think of this as the entry point to our Go// programfunc main() {  // within this main function, we then  // want to call a function within the fmt  // package called Println() in order to print  // out `Hello World`  fmt. Println( Hello World )}이게 끝입니다. 이 5줄의 코드를 추가한 후에 PATH에 있는 go 바이너리를 사용하여 이 코드를 실행하고 컴파일하도록 설정할 수 있습니다. 12$ go run main. goHello World이것을 바이너리 실행 파일로 컴파일하려면 go 바이너리를 다음과 같이 사용하면 됩니다. 12$ go build main. go$ . /main 축하합니다 - 첫 번째 Go 응용 프로그램을 성공적으로 작성, 실행 및 컴파일했습니다!   결론: 이제 이 간단한 튜토리얼에서 Go개발 세계로의 여행을 성공적으로 시작했습니다. Go 기술을 향상시키는데 관심이 있으시면 Go에서 사용할 수있는 기본 유형에 대해 이 튜토리얼의 다음 포스트를 확인하세요 - Go 기본 타입 튜토리얼 "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});